<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Vbase</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Vbase</h1>

<div class="code">

<br/>
<span class="comment">(*&nbsp;*********************************************************************)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic&nbsp;lemmas&nbsp;&amp;&nbsp;tactics&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;*********************************************************************)</span><br/>

<br/>
</div>

<div class="doc">
This file collects a number of basic lemmas and tactics for better
    proof automation, structuring large proofs, or rewriting.  Most of 
    the rewriting support is ported from ss-reflect. 
<div class="paragraph"> </div>

 Symbols starting with <span class="inlinecode"><span class="id" type="var">vlib__</span></span> are internal. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Logic.Eqdep.html#"><span class="id" type="library">Logic.Eqdep</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Bool.Bool.html#"><span class="id" type="library">Bool</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Arith.Arith.html#"><span class="id" type="library">Arith</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.ZArith.ZArith.html#"><span class="id" type="library">ZArith</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Strings.String.html#"><span class="id" type="library">String</span></a>.<br/>

<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">bool_scope</span>.<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Set Implicit Arguments</span>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">Axioms</h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Require</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Logic.ClassicalFacts.html#"><span class="id" type="library">ClassicalFacts</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Logic.FunctionalExtensionality.html#"><span class="id" type="library">FunctionalExtensionality</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Logic.ProofIrrelevance.html#"><span class="id" type="library">ProofIrrelevance</span></a>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">exten</span> := <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" type="lemma">functional_extensionality</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab4"></a><h1 class="section">Coersion of <span class="inlinecode"><span class="id" type="var">bool</span></span> into <span class="inlinecode"><span class="id" type="keyword">Prop</span></span></h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coersion of bools into Prop 
</div>
<div class="code">
<span class="id" type="keyword">Coercion</span> <span class="id" type="var">is_true</span> (<span class="id" type="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>) : <span class="id" type="keyword">Prop</span> := <a class="idref" href="Vbase.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>.<br/>

<br/>
</div>

<div class="doc">
Hints for auto 
</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="vlib__true_is_true"><span class="id" type="lemma">vlib__true_is_true</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__not_false_is_true"><span class="id" type="lemma">vlib__not_false_is_true</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Hint Resolve</span> <a class="idref" href="Vbase.html#vlib__true_is_true"><span class="id" type="lemma">vlib__true_is_true</span></a> <a class="idref" href="Vbase.html#vlib__not_false_is_true"><span class="id" type="lemma">vlib__not_false_is_true</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab5"></a><h1 class="section">Very basic automation</h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Set up for basic simplification 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Adaptation of the ss-reflect "<span class="inlinecode"><span class="id" type="var">done</span></span>" tactic. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">vlib__basic_done</span> := <br/>
&nbsp;&nbsp;<span class="id" type="tactic">solve</span> [<span class="id" type="tactic">trivial</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib</span> | <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#sym_equal"><span class="id" type="abbreviation">sym_equal</span></a>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">discriminate</span> | <span class="id" type="var">contradiction</span>].<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">done</span> := <span class="id" type="tactic">trivial</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib</span>; <span class="id" type="tactic">hnf</span>; <span class="id" type="tactic">intros</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">solve</span> [<span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <span class="id" type="var">vlib__basic_done</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">case</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>] <span class="id" type="keyword">end</span>].<br/>

<br/>
</div>

<div class="doc">
A variant of the ssr "done" tactic that performs "eassumption". 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">edone</span> := <span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">hnf</span>; <span class="id" type="tactic">intros</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">solve</span> [<span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">vlib__basic_done</span>; <span class="id" type="tactic">split</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">eassumption</span>; <span class="id" type="var">vlib__basic_done</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">case</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>] <span class="id" type="keyword">end</span>].<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "by"  <span class="id" type="var">tactic</span>(<span class="id" type="var">tac</span>) := (<span class="id" type="var">tac</span>; <span class="id" type="var">done</span>).<br/>
<span class="id" type="keyword">Tactic Notation</span> "eby" <span class="id" type="var">tactic</span>(<span class="id" type="var">tac</span>) := (<span class="id" type="var">tac</span>; <span class="id" type="var">edone</span>).<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab6"></a><h1 class="section">Boolean reflection</h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
These definitions are ported from ssr-bool. 
<div class="paragraph"> </div>

 Negation lemmas 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="NegationLemmas"><span class="id" type="section">NegationLemmas</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Variables</span> (<a name="NegationLemmas.b"><span class="id" type="variable">b</span></a> <a name="NegationLemmas.c"><span class="id" type="variable">c</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbT"><span class="id" type="lemma">negbT</span></a> : <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a>.<br/>
 &nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbTE"><span class="id" type="lemma">negbTE</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 &nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbF"><span class="id" type="lemma">negbF</span></a> : <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 &nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbFE"><span class="id" type="lemma">negbFE</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a>.<br/>
 &nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbNE"><span class="id" type="lemma">negbNE</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a>) -&gt; <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a>.<br/>
 
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbLR"><span class="id" type="lemma">negbLR</span></a> : <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.c"><span class="id" type="variable">c</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#NegationLemmas.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="negbRL"><span class="id" type="lemma">negbRL</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#NegationLemmas.c"><span class="id" type="variable">c</span></a> -&gt; <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="contra"><span class="id" type="lemma">contra</span></a> : (<a class="idref" href="Vbase.html#NegationLemmas.c"><span class="id" type="variable">c</span></a> -&gt; <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a>) -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#NegationLemmas.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#NegationLemmas"><span class="id" type="section">NegationLemmas</span></a>.<br/>

<br/>
</div>

<div class="doc">
Lemmas for ifs, which allow reasoning about the condition without 
    repeating it inside the proof. 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="BoolIf"><span class="id" type="section">BoolIf</span></a>.<br/>

<br/>
<span class="id" type="keyword">Variables</span> (<a name="BoolIf.A"><span class="id" type="variable">A</span></a> <a name="BoolIf.B"><span class="id" type="variable">B</span></a> : <span class="id" type="keyword">Type</span>) (<a name="BoolIf.x"><span class="id" type="variable">x</span></a> : <a class="idref" href="Vbase.html#BoolIf.A"><span class="id" type="variable">A</span></a>) (<a name="BoolIf.f"><span class="id" type="variable">f</span></a> : <a class="idref" href="Vbase.html#BoolIf.A"><span class="id" type="variable">A</span></a> -&gt; <a class="idref" href="Vbase.html#BoolIf.B"><span class="id" type="variable">B</span></a>) (<a name="BoolIf.b"><span class="id" type="variable">b</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>) (<a name="BoolIf.vT"><span class="id" type="variable">vT</span></a> <a name="BoolIf.vF"><span class="id" type="variable">vF</span></a> : <a class="idref" href="Vbase.html#BoolIf.A"><span class="id" type="variable">A</span></a>).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="if_spec"><span class="id" type="inductive">if_spec</span></a> : <a class="idref" href="Vbase.html#BoolIf.A"><span class="id" type="variable">A</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> -&gt; <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <a name="IfSpecTrue"><span class="id" type="constructor">IfSpecTrue</span></a>  : <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a>         -&gt; <a class="idref" href="Vbase.html#if_spec"><span class="id" type="inductive">if_spec</span></a> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a name="IfSpecFalse"><span class="id" type="constructor">IfSpecFalse</span></a> : <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="Vbase.html#if_spec"><span class="id" type="inductive">if_spec</span></a> <a class="idref" href="Vbase.html#BoolIf.vF"><span class="id" type="variable">vF</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="ifP"><span class="id" type="lemma">ifP</span></a> : <a class="idref" href="Vbase.html#if_spec"><span class="id" type="inductive">if_spec</span></a> (<span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#BoolIf.vF"><span class="id" type="variable">vF</span></a>) <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="if_same"><span class="id" type="lemma">if_same</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="if_neg"><span class="id" type="lemma">if_neg</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#BoolIf.vF"><span class="id" type="variable">vF</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#BoolIf.vF"><span class="id" type="variable">vF</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="fun_if"><span class="id" type="lemma">fun_if</span></a> : <a class="idref" href="Vbase.html#BoolIf.f"><span class="id" type="variable">f</span></a> (<span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#BoolIf.vF"><span class="id" type="variable">vF</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#BoolIf.f"><span class="id" type="variable">f</span></a> <a class="idref" href="Vbase.html#BoolIf.vT"><span class="id" type="variable">vT</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#BoolIf.f"><span class="id" type="variable">f</span></a> <a class="idref" href="Vbase.html#BoolIf.vF"><span class="id" type="variable">vF</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="if_arg"><span class="id" type="lemma">if_arg</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">fT</span> <span class="id" type="var">fF</span> : <a class="idref" href="Vbase.html#BoolIf.A"><span class="id" type="variable">A</span></a> -&gt; <a class="idref" href="Vbase.html#BoolIf.B"><span class="id" type="variable">B</span></a>,<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#fT"><span class="id" type="variable">fT</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#fF"><span class="id" type="variable">fF</span></a>) <a class="idref" href="Vbase.html#BoolIf.x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#BoolIf.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#fT"><span class="id" type="variable">fT</span></a> <a class="idref" href="Vbase.html#BoolIf.x"><span class="id" type="variable">x</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#fF"><span class="id" type="variable">fF</span></a> <a class="idref" href="Vbase.html#BoolIf.x"><span class="id" type="variable">x</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#BoolIf"><span class="id" type="section">BoolIf</span></a>.<br/>

<br/>
</div>

<div class="doc">
The reflection predicate 
</div>
<div class="code">
<span class="id" type="keyword">Inductive</span> <a name="reflect"><span class="id" type="inductive">reflect</span></a> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> -&gt; <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <a name="ReflectT"><span class="id" type="constructor">ReflectT</span></a> : <span class="id" type="var">P</span> -&gt; <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <span class="id" type="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a name="ReflectF"><span class="id" type="constructor">ReflectF</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span> -&gt; <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <span class="id" type="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
</div>

<div class="doc">
Internal reflection lemmas 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="ReflectCore"><span class="id" type="section">ReflectCore</span></a>.<br/>

<br/>
<span class="id" type="keyword">Variables</span> (<a name="ReflectCore.P"><span class="id" type="variable">P</span></a> : <span class="id" type="keyword">Prop</span>) (<a name="ReflectCore.b"><span class="id" type="variable">b</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>) (<a name="ReflectCore.Hb"><span class="id" type="variable">Hb</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a>) (<a name="ReflectCore.Q"><span class="id" type="variable">Q</span></a> : <span class="id" type="keyword">Prop</span>) (<a name="ReflectCore.c"><span class="id" type="variable">c</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="introNTF"><span class="id" type="lemma">introNTF</span></a> : (<span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a>) -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="introTF"><span class="id" type="lemma">introTF</span></a> : (<span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a>) -&gt; <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="elimNTF"><span class="id" type="lemma">elimNTF</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a> -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="elimTF"><span class="id" type="lemma">elimTF</span></a> : <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a> -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectCore.c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="equivPif"><span class="id" type="lemma">equivPif</span></a> : (<a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a> -&gt; <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a>) -&gt; (<a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a>) -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="xorPif"><span class="id" type="lemma">xorPif</span></a> : <a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Vbase.html#ReflectCore.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectCore.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#ReflectCore.Q"><span class="id" type="variable">Q</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#ReflectCore"><span class="id" type="section">ReflectCore</span></a>.<br/>

<br/>
</div>

<div class="doc">
Internal negated reflection lemmas 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="ReflectNegCore"><span class="id" type="section">ReflectNegCore</span></a>.<br/>

<br/>
<span class="id" type="keyword">Variables</span> (<a name="ReflectNegCore.P"><span class="id" type="variable">P</span></a> : <span class="id" type="keyword">Prop</span>) (<a name="ReflectNegCore.b"><span class="id" type="variable">b</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>) (<a name="ReflectNegCore.Hb"><span class="id" type="variable">Hb</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.b"><span class="id" type="variable">b</span></a>)) (<a name="ReflectNegCore.Q"><span class="id" type="variable">Q</span></a> : <span class="id" type="keyword">Prop</span>) (<a name="ReflectNegCore.c"><span class="id" type="variable">c</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="introTFn"><span class="id" type="lemma">introTFn</span></a> : (<span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectNegCore.c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a>) -&gt; <a class="idref" href="Vbase.html#ReflectNegCore.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="elimTFn"><span class="id" type="lemma">elimTFn</span></a> : <a class="idref" href="Vbase.html#ReflectNegCore.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.c"><span class="id" type="variable">c</span></a> -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectNegCore.c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="equivPifn"><span class="id" type="lemma">equivPifn</span></a> : (<a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a> -&gt; <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a>) -&gt; (<a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a>) -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectNegCore.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="xorPifn"><span class="id" type="lemma">xorPifn</span></a> : <a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> -&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#ReflectNegCore.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectNegCore.Q"><span class="id" type="variable">Q</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#ReflectNegCore"><span class="id" type="section">ReflectNegCore</span></a>.<br/>

<br/>
</div>

<div class="doc">
User-oriented reflection lemmas 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="Reflect"><span class="id" type="section">Reflect</span></a>.<br/>

<br/>
<span class="id" type="keyword">Variables</span> (<a name="Reflect.P"><span class="id" type="variable">P</span></a> <a name="Reflect.Q"><span class="id" type="variable">Q</span></a> : <span class="id" type="keyword">Prop</span>) (<a name="Reflect.b"><span class="id" type="variable">b</span></a> <a name="Reflect.b'"><span class="id" type="variable">b'</span></a> <a name="Reflect.c"><span class="id" type="variable">c</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>).<br/>
<span class="id" type="keyword">Hypotheses</span> (<a name="Reflect.Pb"><span class="id" type="variable">Pb</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a>) (<a name="Reflect.Pb'"><span class="id" type="variable">Pb'</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#Reflect.b'"><span class="id" type="variable">b'</span></a>)).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="introT"><span class="id" type="lemma">introT</span></a>  : <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="introF"><span class="id" type="lemma">introF</span></a>  : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="introN"><span class="id" type="lemma">introN</span></a>  : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="introNf"><span class="id" type="lemma">introNf</span></a> : <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="introTn"><span class="id" type="lemma">introTn</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.b'"><span class="id" type="variable">b'</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="introFn"><span class="id" type="lemma">introFn</span></a> : <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.b'"><span class="id" type="variable">b'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="elimT"><span class="id" type="lemma">elimT</span></a>  : <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="elimF"><span class="id" type="lemma">elimF</span></a>  : <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="elimN"><span class="id" type="lemma">elimN</span></a>  : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a><a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="elimNf"><span class="id" type="lemma">elimNf</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="elimTn"><span class="id" type="lemma">elimTn</span></a> : <a class="idref" href="Vbase.html#Reflect.b'"><span class="id" type="variable">b'</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 <span class="id" type="keyword">Lemma</span> <a name="elimFn"><span class="id" type="lemma">elimFn</span></a> : <a class="idref" href="Vbase.html#Reflect.b'"><span class="id" type="variable">b'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="introP"><span class="id" type="lemma">introP</span></a> : (<a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a>) -&gt; (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a>) -&gt; <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="iffP"><span class="id" type="lemma">iffP</span></a> : (<a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a>) -&gt; (<a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>) -&gt; <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="appP"><span class="id" type="lemma">appP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.Q"><span class="id" type="variable">Q</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="sameP"><span class="id" type="lemma">sameP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> <a class="idref" href="Vbase.html#Reflect.c"><span class="id" type="variable">c</span></a> -&gt; <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#Reflect.c"><span class="id" type="variable">c</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="decPcases"><span class="id" type="lemma">decPcases</span></a> : <span class="id" type="keyword">if</span> <a class="idref" href="Vbase.html#Reflect.b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Definition</span> <a name="decP"><span class="id" type="definition">decP</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a><a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#Reflect.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#Reflect"><span class="id" type="section">Reflect</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;Allow&nbsp;the&nbsp;direct&nbsp;application&nbsp;of&nbsp;a&nbsp;reflection&nbsp;lemma&nbsp;to&nbsp;a&nbsp;boolean&nbsp;assertion.&nbsp;&nbsp;*)</span><br/>
<span class="id" type="keyword">Coercion</span> <a class="idref" href="Vbase.html#elimT"><span class="id" type="lemma">elimT</span></a> : <span class="id" type="var">reflect</span> &gt;-&gt; <span class="id" type="var">Funclass</span>.<br/>

<br/>
<span class="id" type="keyword">Section</span> <a name="ReflectConnectives"><span class="id" type="section">ReflectConnectives</span></a>.<br/>

<br/>
<span class="id" type="keyword">Variable</span> <a name="ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a name="ReflectConnectives.b2"><span class="id" type="variable">b2</span></a> <a name="ReflectConnectives.b3"><span class="id" type="variable">b3</span></a> <a name="ReflectConnectives.b4"><span class="id" type="variable">b4</span></a> <a name="ReflectConnectives.b5"><span class="id" type="variable">b5</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="idP"><span class="id" type="lemma">idP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="idPn"><span class="id" type="lemma">idPn</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="negP"><span class="id" type="lemma">negP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="negPn"><span class="id" type="lemma">negPn</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>)).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="negPf"><span class="id" type="lemma">negPf</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="andP"><span class="id" type="lemma">andP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>) (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="orP"><span class="id" type="lemma">orP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>) (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="nandP"><span class="id" type="lemma">nandP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>)).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="norP"><span class="id" type="lemma">norP</span></a> : <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="Vbase.html#ReflectConnectives.b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Vbase.html#ReflectConnectives.b2"><span class="id" type="variable">b2</span></a>)).<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#ReflectConnectives"><span class="id" type="section">ReflectConnectives</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab7"></a><h1 class="section">Equality types</h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
These definitions are ported from ssr-eq. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="phantom"><span class="id" type="inductive">phantom</span></a> (<span class="id" type="var">T</span> :  <span class="id" type="keyword">Type</span>) (<span class="id" type="var">p</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>) :  <span class="id" type="keyword">Type</span> := <a name="Phantom"><span class="id" type="constructor">Phantom</span></a>.<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Vbase.html#phantom"><span class="id" type="inductive">phantom</span></a> [].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Vbase.html#Phantom"><span class="id" type="constructor">Phantom</span></a> [].<br/>
<span class="id" type="keyword">Definition</span> <a name="phant_id"><span class="id" type="definition">phant_id</span></a> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span> <span class="id" type="var">v1</span> <span class="id" type="var">v2</span> := <a class="idref" href="Vbase.html#phantom"><span class="id" type="inductive">phantom</span></a> <a class="idref" href="Vbase.html#T1"><span class="id" type="variable">T1</span></a> <a class="idref" href="Vbase.html#v1"><span class="id" type="variable">v1</span></a> -&gt; <a class="idref" href="Vbase.html#phantom"><span class="id" type="inductive">phantom</span></a> <a class="idref" href="Vbase.html#T2"><span class="id" type="variable">T2</span></a> <a class="idref" href="Vbase.html#v2"><span class="id" type="variable">v2</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="idfun"><span class="id" type="definition">idfun</span></a> <span class="id" type="var">T</span> := (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a> =&gt; <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="id" type="keyword">Module</span> <a name="Equality"><span class="id" type="module">Equality</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Equality.axiom"><span class="id" type="definition">axiom</span></a> <span class="id" type="var">T</span> (<span class="id" type="var">e</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a> -&gt; <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>) := <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="Vbase.html#Equality.reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a>) (<a class="idref" href="Vbase.html#e"><span class="id" type="variable">e</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a>).<br/>

<br/>
<span class="id" type="keyword">Structure</span> <a name="Equality.mixin_of"><span class="id" type="record">mixin_of</span></a> <span class="id" type="var">T</span> := <a name="Equality.Mixin"><span class="id" type="constructor">Mixin</span></a> {<a name="Equality.op"><span class="id" type="projection">op</span></a> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a> -&gt; <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>; <span class="id" type="var">_</span> : <a class="idref" href="Vbase.html#Equality.axiom"><span class="id" type="definition">axiom</span></a> <a class="idref" href="Vbase.html#op"><span class="id" type="method">op</span></a>}.<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.class_of"><span class="id" type="abbreviation">class_of</span></a> := <a class="idref" href="Vbase.html#Equality.mixin_of"><span class="id" type="record">mixin_of</span></a> (<span class="id" type="var">only</span> <span class="id" type="var">parsing</span>).<br/>

<br/>
<span class="id" type="keyword">Section</span> <a name="Equality.ClassDef"><span class="id" type="section">ClassDef</span></a>.<br/>

<br/>
<span class="id" type="keyword">Structure</span> <a name="Equality.type"><span class="id" type="record">type</span></a> := <a name="Equality.Pack"><span class="id" type="constructor">Pack</span></a> {<a name="Equality.sort"><span class="id" type="projection">sort</span></a>; <span class="id" type="var">_</span> : <a class="idref" href="Vbase.html#Equality.class_of"><span class="id" type="abbreviation">class_of</span></a> <a class="idref" href="Vbase.html#sort"><span class="id" type="method">sort</span></a>; <span class="id" type="var">_</span> : <span class="id" type="keyword">Type</span>}.<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Coercion</span> <a class="idref" href="Vbase.html#Equality.sort"><span class="id" type="projection">sort</span></a> : <span class="id" type="var">type</span> &gt;-&gt; <span class="id" type="var">Sortclass</span>.<br/>
<span class="id" type="keyword">Variables</span> (<a name="Equality.ClassDef.T"><span class="id" type="variable">T</span></a> : <span class="id" type="keyword">Type</span>) (<a name="Equality.ClassDef.cT"><span class="id" type="variable">cT</span></a> : <a class="idref" href="Vbase.html#Equality.type"><span class="id" type="record">type</span></a>).<br/>
<span class="id" type="keyword">Definition</span> <a name="Equality.class"><span class="id" type="definition">class</span></a> <span class="id" type="var">cT'</span> := <span class="id" type="keyword">match</span> <a class="idref" href="Vbase.html#cT'"><span class="id" type="variable">cT'</span></a> <span class="id" type="keyword">return</span> <a class="idref" href="Vbase.html#Equality.class_of"><span class="id" type="abbreviation">class_of</span></a> <a class="idref" href="Vbase.html#cT'"><span class="id" type="variable">cT'</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Vbase.html#Equality.Pack"><span class="id" type="constructor">Pack</span></a> <span class="id" type="var">_</span> <span class="id" type="var">c</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">c</span> <span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Equality.pack"><span class="id" type="definition">pack</span></a> <span class="id" type="var">c</span> := @<a class="idref" href="Vbase.html#Equality.Pack"><span class="id" type="constructor">Pack</span></a> <a class="idref" href="Vbase.html#Equality.ClassDef.T"><span class="id" type="variable">T</span></a> <a class="idref" href="Vbase.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Vbase.html#Equality.ClassDef.T"><span class="id" type="variable">T</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="Equality.clone"><span class="id" type="definition">clone</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">c</span> (<span class="id" type="var">_</span> : <a class="idref" href="Vbase.html#Equality.ClassDef.cT"><span class="id" type="variable">cT</span></a> -&gt; <a class="idref" href="Vbase.html#Equality.ClassDef.T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">_</span> : <a class="idref" href="Vbase.html#Equality.phant_id"><span class="id" type="definition">phant_id</span></a> (<a class="idref" href="Vbase.html#Equality.pack"><span class="id" type="definition">pack</span></a> <a class="idref" href="Vbase.html#c"><span class="id" type="variable">c</span></a>) <a class="idref" href="Vbase.html#Equality.ClassDef.cT"><span class="id" type="variable">cT</span></a>) =&gt; <a class="idref" href="Vbase.html#Equality.pack"><span class="id" type="definition">pack</span></a> <a class="idref" href="Vbase.html#c"><span class="id" type="variable">c</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#Equality.ClassDef"><span class="id" type="section">ClassDef</span></a>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <a name="Equality.Exports"><span class="id" type="module">Exports</span></a>.<br/>
<span class="id" type="keyword">Coercion</span> <a class="idref" href="Vbase.html#Equality.Exports.sort"><span class="id" type="projection">sort</span></a> : <span class="id" type="var">type</span> &gt;-&gt; <span class="id" type="var">Sortclass</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.Exports.eqType"><span class="id" type="abbreviation">eqType</span></a> := <a class="idref" href="Vbase.html#Equality.Exports.type"><span class="id" type="record">type</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.Exports.EqMixin"><span class="id" type="abbreviation">EqMixin</span></a> := <a class="idref" href="Vbase.html#Equality.Exports.Mixin"><span class="id" type="constructor">Mixin</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.Exports.EqType"><span class="id" type="abbreviation">EqType</span></a> <span class="id" type="var">T</span> <span class="id" type="var">m</span> := (@<a class="idref" href="Vbase.html#Equality.Exports.pack"><span class="id" type="definition">pack</span></a> <span class="id" type="var">T</span> <span class="id" type="var">m</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.Exports.:form_scope:'['_'eqMixin'_'of'_x_']'"><span class="id" type="notation">"</span></a>[ 'eqMixin' 'of' T ]" := (<a class="idref" href="Vbase.html#Equality.Exports.class"><span class="id" type="definition">class</span></a> <span class="id" type="var">_</span> : <a class="idref" href="Vbase.html#Equality.Exports.mixin_of"><span class="id" type="record">mixin_of</span></a> <span class="id" type="var">T</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 0, <span class="id" type="var">format</span> "[ 'eqMixin'  'of'  T ]") : <span class="id" type="var">form_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.Exports.:form_scope:'['_'eqType'_'of'_x_'for'_x_']'"><span class="id" type="notation">"</span></a>[ 'eqType' 'of' T 'for' C ]" := (@<a class="idref" href="Vbase.html#Equality.Exports.clone"><span class="id" type="definition">clone</span></a> <span class="id" type="var">T</span> <span class="id" type="var">C</span> <span class="id" type="var">_</span> <a class="idref" href="Vbase.html#Equality.Exports.idfun"><span class="id" type="definition">idfun</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#id"><span class="id" type="definition">id</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 0, <span class="id" type="var">format</span> "[ 'eqType'  'of'  T  'for'  C ]") : <span class="id" type="var">form_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Equality.Exports.:form_scope:'['_'eqType'_'of'_x_']'"><span class="id" type="notation">"</span></a>[ 'eqType' 'of' T ]" := (@<a class="idref" href="Vbase.html#Equality.Exports.clone"><span class="id" type="definition">clone</span></a> <span class="id" type="var">T</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#id"><span class="id" type="definition">id</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#id"><span class="id" type="definition">id</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 0, <span class="id" type="var">format</span> "[ 'eqType'  'of'  T ]") : <span class="id" type="var">form_scope</span>.<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#Exports"><span class="id" type="module">Exports</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Vbase.html#"><span class="id" type="module">Equality</span></a>.<br/>
<span class="id" type="keyword">Export</span> <span class="id" type="var">Equality.Exports</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="eq_op"><span class="id" type="definition">eq_op</span></a> <span class="id" type="var">T</span> := <a class="idref" href="Vbase.html#Equality.op"><span class="id" type="projection">Equality.op</span></a> (<a class="idref" href="Vbase.html#Equality.class"><span class="id" type="definition">Equality.class</span></a> <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>).<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Vbase.html#eq_op"><span class="id" type="definition">eq_op</span></a> [[<span class="id" type="var">T</span>]].<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="eqE"><span class="id" type="lemma">eqE</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">T</span> <span class="id" type="var">x</span>, <a class="idref" href="Vbase.html#eq_op"><span class="id" type="definition">eq_op</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#Equality.op"><span class="id" type="projection">Equality.op</span></a> (<a class="idref" href="Vbase.html#Equality.class"><span class="id" type="definition">Equality.class</span></a> <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>) <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="eqP"><span class="id" type="lemma">eqP</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">T</span>, <a class="idref" href="Vbase.html#Equality.axiom"><span class="id" type="definition">Equality.axiom</span></a> (@<a class="idref" href="Vbase.html#eq_op"><span class="id" type="definition">eq_op</span></a> <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>).<br/>
 <span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Vbase.html#eqP"><span class="id" type="lemma">eqP</span></a> [<span class="id" type="var">T</span>].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":bool_scope:x_'=='_x"><span class="id" type="notation">"</span></a>x == y" := (<a class="idref" href="Vbase.html#eq_op"><span class="id" type="definition">eq_op</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="keyword">no</span> <span class="id" type="keyword">associativity</span>) : <span class="id" type="var">bool_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":bool_scope:x_'=='_x_':>'_x"><span class="id" type="notation">"</span></a>x == y :&gt; T" := (<a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">(</span></a><span class="id" type="var">x</span> : <span class="id" type="var">T</span><a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">(</span></a><span class="id" type="var">y</span> : <span class="id" type="var">T</span><a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">)</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="var">y</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>) : <span class="id" type="var">bool_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":bool_scope:x_'!='_x"><span class="id" type="notation">"</span></a>x != y" := (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<span class="id" type="var">x</span> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <span class="id" type="var">y</span>))<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="keyword">no</span> <span class="id" type="keyword">associativity</span>) : <span class="id" type="var">bool_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":bool_scope:x_'!='_x_':>'_x"><span class="id" type="notation">"</span></a>x != y :&gt; T" := (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> (<span class="id" type="var">x</span> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x_':>'_x"><span class="id" type="notation">==</span></a> <span class="id" type="var">y</span> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x_':>'_x"><span class="id" type="notation">:&gt;</span></a> <span class="id" type="var">T</span>))<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 70, <span class="id" type="var">y</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>) : <span class="id" type="var">bool_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__internal_eqP"><span class="id" type="lemma">vlib__internal_eqP</span></a> : <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span>: <a class="idref" href="Vbase.html#Equality.Exports.eqType"><span class="id" type="abbreviation">eqType</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>), <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a>) (<a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="neqP"><span class="id" type="lemma">neqP</span></a> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span>: <a class="idref" href="Vbase.html#Equality.Exports.eqType"><span class="id" type="abbreviation">eqType</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span>: <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>), <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">&lt;&gt;</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a>) (<a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'!='_x"><span class="id" type="notation">!=</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="beq_refl"><span class="id" type="lemma">beq_refl</span></a> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span> : <a class="idref" href="Vbase.html#Equality.Exports.eqType"><span class="id" type="abbreviation">eqType</span></a>) (<span class="id" type="var">x</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>), <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="beq_sym"><span class="id" type="lemma">beq_sym</span></a> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span> : <a class="idref" href="Vbase.html#Equality.Exports.eqType"><span class="id" type="abbreviation">eqType</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Hint Resolve</span> <a class="idref" href="Vbase.html#beq_refl"><span class="id" type="lemma">beq_refl</span></a> : <span class="id" type="var">vlib</span>.<br/>
<span class="id" type="keyword">Hint Rewrite</span> <a class="idref" href="Vbase.html#beq_refl"><span class="id" type="lemma">beq_refl</span></a> : <span class="id" type="var">vlib_trivial</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="eqxx"><span class="id" type="abbreviation">eqxx</span></a> := <a class="idref" href="Vbase.html#beq_refl"><span class="id" type="lemma">beq_refl</span></a>.<br/>

<br/>
<span class="comment">(*<br/>
Implicit&nbsp;Arguments&nbsp;idP&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;idPn&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;negP&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;negn&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;negPf&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;andP&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span> <span class="inlinecode"><span class="id" type="var">b2</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;orP&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span> <span class="inlinecode"><span class="id" type="var">b2</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;nandP&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span> <span class="inlinecode"><span class="id" type="var">b2</span></span>.<br/>
Implicit&nbsp;Arguments&nbsp;norP&nbsp;<span class="inlinecode"><span class="id" type="var">b1</span></span> <span class="inlinecode"><span class="id" type="var">b2</span></span>.<br/>
*)</span><br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab8"></a><h1 class="section">Basic simplification tactics</h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__negb_rewrite"><span class="id" type="lemma">vlib__negb_rewrite</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Vbase.html#b"><span class="id" type="variable">b</span></a> -&gt; <a class="idref" href="Vbase.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__andb_split"><span class="id" type="lemma">vlib__andb_split</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>, <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> -&gt; <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__nandb_split"><span class="id" type="lemma">vlib__nandb_split</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>, <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__orb_split"><span class="id" type="lemma">vlib__orb_split</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>, <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> -&gt; <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__norb_split"><span class="id" type="lemma">vlib__norb_split</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>, <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> -&gt; <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__eqb_split"><span class="id" type="lemma">vlib__eqb_split</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a>, (<a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> -&gt; <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a>) -&gt; (<a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a> -&gt; <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a>) -&gt; <a class="idref" href="Vbase.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#b2"><span class="id" type="variable">b2</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="vlib__beq_rewrite"><span class="id" type="lemma">vlib__beq_rewrite</span></a> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span> : <a class="idref" href="Vbase.html#Equality.Exports.eqType"><span class="id" type="abbreviation">eqType</span></a>) (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> : <a class="idref" href="Vbase.html#T"><span class="id" type="variable">T</span></a>), <a class="idref" href="Vbase.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <a class="idref" href="Vbase.html#x2"><span class="id" type="variable">x2</span></a> -&gt; <a class="idref" href="Vbase.html#x1"><span class="id" type="variable">x1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Vbase.html#x2"><span class="id" type="variable">x2</span></a>.<br/>
 
<br/>
</div>

<div class="doc">
Set up for basic simplification: database of reflection lemmas 
</div>
<div class="code">

<br/>

<br/>
<span class="id" type="keyword">Hint Resolve</span> <a class="idref" href="Vbase.html#andP"><span class="id" type="lemma">andP</span></a> <a class="idref" href="Vbase.html#orP"><span class="id" type="lemma">orP</span></a> <a class="idref" href="Vbase.html#nandP"><span class="id" type="lemma">nandP</span></a> <a class="idref" href="Vbase.html#norP"><span class="id" type="lemma">norP</span></a> <a class="idref" href="Vbase.html#negP"><span class="id" type="lemma">negP</span></a> <a class="idref" href="Vbase.html#vlib__internal_eqP"><span class="id" type="lemma">vlib__internal_eqP</span></a> <a class="idref" href="Vbase.html#neqP"><span class="id" type="lemma">neqP</span></a> : <span class="id" type="var">vlib_refl</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">X</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;(<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> | [|- ?<span class="id" type="var">P</span> ] =&gt; <span class="id" type="tactic">set</span> (<span class="id" type="var">X</span> := <span class="id" type="var">P</span>) <span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;<span class="id" type="tactic">injection</span> <span class="id" type="var">H</span>;<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;&nbsp;(lazymatch&nbsp;goal&nbsp;with&nbsp;|&nbsp;<span class="inlinecode"></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" type="var">_</span></span>&nbsp;=&gt;&nbsp;fail&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;idtac&nbsp;end);&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Previous&nbsp;statement&nbsp;no&nbsp;longer&nbsp;necessary&nbsp;in&nbsp;8.4&nbsp;*)</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">X</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">subst</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">vlib__clarify1</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">subst</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span>] =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__andb_split"><span class="id" type="lemma">vlib__andb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> ?<span class="id" type="var">x</span>) |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Vbase.html#vlib__negb_rewrite"><span class="id" type="lemma">vlib__negb_rewrite</span></a> <span class="id" type="var">H</span>) <span class="id" type="keyword">in</span> *<br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> ?<span class="id" type="var">x</span>        |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> *<br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>         |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> *<br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>        |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> *<br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<span class="id" type="var">_</span> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <span class="id" type="var">_</span>)  |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="tactic">generalize</span> (<a class="idref" href="Vbase.html#vlib__beq_rewrite"><span class="id" type="lemma">vlib__beq_rewrite</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: @<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> @<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Logic.ProofIrrelevance.html#ProofIrrelevanceTheory.EqdepTheory.inj_pair2"><span class="id" type="lemma">inj_pair2</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">subst</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span>             <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span>             |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>           <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>           |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>         <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>         |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>       <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>       |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>     <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>     |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>   <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>   |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;| [<span class="id" type="var">H</span>: ?<span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">f</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span>] =&gt; <span class="id" type="var">vlib__complaining_inj</span> <span class="id" type="var">f</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>.<br/>

<br/>
</div>

<div class="doc">
Perform injections &amp; discriminations on all hypotheses 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clarify</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">vlib__clarify1</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H1</span>: ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">_</span>, <span class="id" type="var">H2</span>: ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>   |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H2</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">discriminate</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H1</span>: ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">_</span>, <span class="id" type="var">H2</span>: ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H2</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>; <span class="id" type="var">vlib__clarify1</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>; <span class="comment">(*&nbsp;autorewrite&nbsp;with&nbsp;vlib_trivial;&nbsp;*)</span> <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>.<br/>

<br/>
</div>

<div class="doc">
Kill simple goals that require up to two econstructor calls. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">vauto</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">clarify</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">edone</span>; <br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">econstructor</span> (<span class="id" type="tactic">solve</span> [<span class="id" type="var">edone</span> | <span class="id" type="tactic">econstructor</span> (<span class="id" type="var">edone</span>) ]))).<br/>

<br/>
</div>

<div class="doc">
Check that the hypothesis <span class="inlinecode"><span class="id" type="var">id</span></span> is defined. This is useful to make sure that
    an <span class="inlinecode"><span class="id" type="tactic">assert</span></span> has been completely finished. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">end_assert</span> <span class="id" type="var">id</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">m</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;<span class="id" type="tactic">pose</span> (<span class="id" type="var">m</span> := <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#refl_equal"><span class="id" type="abbreviation">refl_equal</span></a> <span class="id" type="var">id</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">m</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">inv</span> <span class="id" type="var">x</span> := <span class="id" type="tactic">inversion</span> <span class="id" type="var">x</span>; <span class="id" type="var">clarify</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpls</span>  := <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">ins</span> := <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>; <span class="id" type="tactic">intros</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "case_eq" <span class="id" type="keyword">constr</span>(<span class="id" type="var">x</span>) := <span class="id" type="var">case_eq</span> (<span class="id" type="var">x</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "case_eq" <span class="id" type="keyword">constr</span>(<span class="id" type="var">x</span>) "as" <span class="id" type="var">simple_intropattern</span>(<span class="id" type="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> [] <span class="id" type="var">_eqn</span>: <span class="id" type="var">H</span>; <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">vlib__clarsimp1</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">clarify</span>; (<span class="id" type="tactic">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_trivial</span> <span class="id" type="var">vlib</span> <span class="id" type="keyword">in</span> * ); <br/>
&nbsp;&nbsp;(<span class="id" type="tactic">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_trivial</span> <span class="id" type="keyword">in</span> * ); <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>;<br/>
&nbsp;&nbsp;<span class="id" type="var">clarify</span>; <span class="id" type="tactic">auto</span> 1 <span class="id" type="keyword">with</span> <span class="id" type="var">vlib</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clarsimp</span> := <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> *; <span class="id" type="var">vlib__clarsimp1</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">autos</span>   := <span class="id" type="var">clarsimp</span>; <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib</span>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
Destruct but give useful names 
</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">P</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" type="inductive">unit</span></a> -&gt; <a class="idref" href="Vbase.html#A"><span class="id" type="variable">A</span></a>) : <a class="idref" href="Vbase.html#A"><span class="id" type="variable">A</span></a> := <a class="idref" href="Vbase.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" type="constructor">tt</span></a>.<br/>

<br/>
<span class="comment">(*Notation&nbsp;"&lt;&lt;&nbsp;x&nbsp;:&nbsp;t&nbsp;&gt;&gt;"&nbsp;:=&nbsp;(NW&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;t))&nbsp;(at&nbsp;level&nbsp;80,&nbsp;x&nbsp;ident,&nbsp;no&nbsp;associativity).<br/>
Notation&nbsp;"&lt;&lt;&nbsp;t&nbsp;&gt;&gt;"&nbsp;:=&nbsp;(NW&nbsp;(fun&nbsp;_&nbsp;=&gt;&nbsp;t))&nbsp;(at&nbsp;level&nbsp;79,&nbsp;no&nbsp;associativity).*)</span><br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">unnw</span> := <span class="id" type="tactic">unfold</span> <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="keyword">in</span> *.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">rednw</span> := <span class="id" type="tactic">red</span>; <span class="id" type="var">unnw</span>.<br/>

<br/>
<span class="id" type="keyword">Hint Unfold</span> <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a>.<br/>

<br/>
</div>

<div class="doc">
Destruct, but no case split 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">desc</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<span class="id" type="var">_</span> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">generalize</span> (<a class="idref" href="Vbase.html#vlib__beq_rewrite"><span class="id" type="lemma">vlib__beq_rewrite</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">exists</span></a> <span class="id" type="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">y</span> =&gt; <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span> <span class="id" type="keyword">let</span> <span class="id" type="var">y'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">y</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">y'</span>]; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">exists</span></a> <span class="id" type="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">?</span></a><span class="id" type="var">p</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">H</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : ?<span class="id" type="var">p</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">q</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">y'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">y'</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__andb_split"><span class="id" type="lemma">vlib__andb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> <span class="id" type="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__norb_split"><span class="id" type="lemma">vlib__norb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> <span class="id" type="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">x</span>   |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span><br/>
<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;is_true&nbsp;?x&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimT&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;?x&nbsp;=&nbsp;true&nbsp;&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimT&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;?x&nbsp;=&nbsp;false&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimFn&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;?x&nbsp;=&nbsp;false&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimF&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span>&nbsp;&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">des</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<span class="id" type="var">_</span> <a class="idref" href="Vbase.html#:bool_scope:x_'=='_x"><span class="id" type="notation">==</span></a> <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">generalize</span> (<a class="idref" href="Vbase.html#vlib__beq_rewrite"><span class="id" type="lemma">vlib__beq_rewrite</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">exists</span></a> <span class="id" type="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">y</span> =&gt; <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span> <span class="id" type="keyword">let</span> <span class="id" type="var">y'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">y</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">y'</span>]; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">exists</span></a> <span class="id" type="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">?</span></a><span class="id" type="var">p</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">H</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists2'_x_','_x_'&'_x"><span class="id" type="notation">exists2</span></a> <span class="id" type="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists2'_x_','_x_'&'_x"><span class="id" type="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists2'_x_','_x_'&'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">p</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists2'_x_','_x_'&'_x"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists2'_x_','_x_'&'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">q</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : ?<span class="id" type="var">p</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">q</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">y'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">y'</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__andb_split"><span class="id" type="lemma">vlib__andb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> <span class="id" type="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__norb_split"><span class="id" type="lemma">vlib__norb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> <span class="id" type="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : ?<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">x</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;is_true&nbsp;?x&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimT&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;?x&nbsp;=&nbsp;true&nbsp;&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimT&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;?x&nbsp;=&nbsp;false&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimFn&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;H:&nbsp;?x&nbsp;=&nbsp;false&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;eapply&nbsp;elimF&nbsp;in&nbsp;H;&nbsp;<span class="inlinecode">|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : ?<span class="id" type="var">p</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">q</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">y'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> <span class="id" type="var">y'</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">unfold</span> <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="tactic">at</span> 1 <span class="id" type="keyword">in</span> <span class="id" type="var">x'</span>; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">unfold</span> <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="tactic">at</span> 1 <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span>; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : ?<span class="id" type="var">p</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">q</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">y'</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">_</span>) =&gt; <span class="id" type="tactic">fresh</span> <span class="id" type="var">z</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="var">H</span> <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> | <span class="id" type="var">y'</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">match</span> <span class="id" type="var">q</span> <span class="id" type="keyword">with</span> | <a class="idref" href="Vbase.html#NW"><span class="id" type="definition">NW</span></a> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y'</span> | <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">idtac</span> <span class="id" type="keyword">end</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="Vbase.html#is_true"><span class="id" type="definition">is_true</span></a> (<span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">_</span>) |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__orb_split"><span class="id" type="lemma">vlib__orb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a> <span class="id" type="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">case</span> (<a class="idref" href="Vbase.html#vlib__nandb_split"><span class="id" type="lemma">vlib__nandb_split</span></a> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">des_if_asm</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">clarify</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="keyword">context</span>[ <span class="id" type="keyword">match</span> ?<span class="id" type="var">x</span> <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span> ] |- <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">x</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> =&gt; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">P</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">evar</span>(<span class="id" type="var">P</span>: <span class="id" type="keyword">Prop</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">Heq</span>: <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">trivial</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_refl</span>); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">Heq</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Heq</span>|<span class="id" type="var">Heq</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> [] <span class="id" type="var">_eqn</span>: <span class="id" type="var">Heq</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">des_if_goal</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">clarify</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">context</span>[<span class="id" type="keyword">match</span> ?<span class="id" type="var">x</span> <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span>] =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">x</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> =&gt; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">P</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">evar</span>(<span class="id" type="var">P</span>: <span class="id" type="keyword">Prop</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">Heq</span>: <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">trivial</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_refl</span>); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">Heq</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Heq</span>|<span class="id" type="var">Heq</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> [] <span class="id" type="var">_eqn</span>: <span class="id" type="var">Heq</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">des_if</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">clarify</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">context</span>[<span class="id" type="keyword">match</span> ?<span class="id" type="var">x</span> <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span>] =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">x</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> =&gt; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">P</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">evar</span>(<span class="id" type="var">P</span>: <span class="id" type="keyword">Prop</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">Heq</span>: <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">trivial</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_refl</span>); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">Heq</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Heq</span>|<span class="id" type="var">Heq</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> [] <span class="id" type="var">_eqn</span>: <span class="id" type="var">Heq</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="keyword">context</span>[ <span class="id" type="keyword">match</span> ?<span class="id" type="var">x</span> <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span> ] |- <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">x</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Specif.html#:type_scope:'{'_x_'}'_'+'_'{'_x_'}'"><span class="id" type="notation">}</span></a> =&gt; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">P</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">evar</span>(<span class="id" type="var">P</span>: <span class="id" type="keyword">Prop</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">Heq</span>: <a class="idref" href="Vbase.html#reflect"><span class="id" type="inductive">reflect</span></a> <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">trivial</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_refl</span>); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">Heq</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Heq</span>|<span class="id" type="var">Heq</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">Heq</span> := <span class="id" type="tactic">fresh</span> "Heq" <span class="id" type="keyword">in</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> [] <span class="id" type="var">_eqn</span>: <span class="id" type="var">Heq</span>; <span class="id" type="var">clarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">des_eqrefl</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="keyword">context</span>[<span class="id" type="keyword">match</span> ?<span class="id" type="var">X</span> <span class="id" type="keyword">as</span> <span class="id" type="var">id</span> <span class="id" type="keyword">return</span> (<a class="idref" href="Vbase.html#id"><span class="id" type="variable">id</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">X</span> -&gt; <span class="id" type="var">_</span>) <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">Logic.eq_refl</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">EQ</span> := <span class="id" type="tactic">fresh</span> "EQ" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">id'</span> := <span class="id" type="tactic">fresh</span> "x" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">revert</span> <span class="id" type="var">H</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">Logic.eq_refl</span></a> <span class="id" type="var">X</span>); <span class="id" type="tactic">generalize</span> <span class="id" type="var">X</span> <span class="id" type="tactic">at</span> 1 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">id'</span> <span class="id" type="var">EQ</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">id'</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">context</span>[<span class="id" type="keyword">match</span> ?<span class="id" type="var">X</span> <span class="id" type="keyword">as</span> <span class="id" type="var">id</span> <span class="id" type="keyword">return</span> (<a class="idref" href="Vbase.html#id"><span class="id" type="variable">id</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">X</span> -&gt; <span class="id" type="var">_</span>) <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">Logic.eq_refl</span></a>] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">EQ</span> := <span class="id" type="tactic">fresh</span> "EQ" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">id'</span> := <span class="id" type="tactic">fresh</span> "x" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">Logic.eq_refl</span></a> <span class="id" type="var">X</span>); <span class="id" type="tactic">generalize</span> <span class="id" type="var">X</span> <span class="id" type="tactic">at</span> 1 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">id'</span> <span class="id" type="var">EQ</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">id'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">desf_asm</span> := <span class="id" type="var">clarify</span>; <span class="id" type="var">des</span>; <span class="id" type="var">des_if_asm</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">desf</span> := <span class="id" type="var">clarify</span>; <span class="id" type="var">des</span>; <span class="id" type="var">des_if</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clarassoc</span> := <span class="id" type="var">clarsimp</span>; <span class="id" type="tactic">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">vlib_trivial</span> <span class="id" type="var">vlib</span> <span class="id" type="var">vlibA</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">try</span> <span class="id" type="var">done</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">vlib__hacksimp1</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">clarsimp</span>;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="var">clarsimp</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="var">clarsimp</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">f_equal</span>; <span class="id" type="var">clarsimp</span>]<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">hacksimp</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">clarsimp</span>;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="var">clarsimp</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="var">clarsimp</span>]<br/>
&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">context</span>[<span class="id" type="keyword">match</span> ?<span class="id" type="var">p</span> <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span>] =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span>; <span class="id" type="var">vlib__hacksimp1</span>]<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">solve</span> [<span class="id" type="tactic">f_equal</span>; <span class="id" type="var">clarsimp</span>]<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab9"></a><h2 class="section">Delineating cases in proofs</h2>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Named case tactics (taken from Libtactics) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "assert_eq" <span class="id" type="var">ident</span>(<span class="id" type="var">x</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">v</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">v</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="tactic">reflexivity</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "Case_aux" <span class="id" type="var">ident</span>(<span class="id" type="var">x</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">name</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span> [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">set</span> (<span class="id" type="var">x</span> := <span class="id" type="var">name</span>); <span class="id" type="tactic">move</span> <span class="id" type="var">x</span> <span class="id" type="tactic">at</span> <span class="id" type="var">top</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">assert_eq</span> <span class="id" type="var">x</span> <span class="id" type="var">name</span><br/>
&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 1 "because we are working on a different case." ].<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">Case</span> <span class="id" type="var">name</span> := <span class="id" type="var">Case_aux</span> <span class="id" type="tactic">case</span> <span class="id" type="var">name</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">SCase</span> <span class="id" type="var">name</span> := <span class="id" type="var">Case_aux</span> <span class="id" type="var">subcase</span> <span class="id" type="var">name</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">SSCase</span> <span class="id" type="var">name</span> := <span class="id" type="var">Case_aux</span> <span class="id" type="var">subsubcase</span> <span class="id" type="var">name</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">SSSCase</span> <span class="id" type="var">name</span> := <span class="id" type="var">Case_aux</span> <span class="id" type="var">subsubsubcase</span> <span class="id" type="var">name</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">SSSSCase</span> <span class="id" type="var">name</span> := <span class="id" type="var">Case_aux</span> <span class="id" type="var">subsubsubsubcase</span> <span class="id" type="var">name</span>.<br/>

<br/>
</div>

<div class="doc">
Lightweight case tactics (without names) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "--" <span class="id" type="var">tactic</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span> [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">WithinCaseM</span> := <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>); <span class="id" type="tactic">move</span> <span class="id" type="var">WithinCaseM</span> <span class="id" type="tactic">at</span> <span class="id" type="var">top</span><br/>
&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 1 "because we are working on a different case." ]; <span class="id" type="var">c</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "++" <span class="id" type="var">tactic</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span> [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">WithinCaseP</span> := <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>); <span class="id" type="tactic">move</span> <span class="id" type="var">WithinCaseP</span> <span class="id" type="tactic">at</span> <span class="id" type="var">top</span><br/>
&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 1 "because we are working on a different case." ]; <span class="id" type="var">c</span>.<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab10"></a><h2 class="section">Exploiting a hypothesis</h2>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Exploit an assumption (adapted from CompCert). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">exploit</span> <span class="id" type="var">x</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>)<br/>
&nbsp;|| <span class="id" type="tactic">refine</span> ((<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <a class="idref" href="Vbase.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Vbase.html#x"><span class="id" type="variable">x</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span>).<br/>

<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab11"></a><h1 class="section">Induction</h1>

</div>
<div class="code">
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>

<br/>
<span class="comment">(*<br/>
Tactic&nbsp;Notation&nbsp;"induction"&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident_list</span>(<span class="id" type="var">y</span>)</span> <span class="inlinecode">"</span>"&nbsp;ident(x)&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"></span>.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induction"&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident_list</span>(<span class="id" type="var">y</span>)</span> <span class="inlinecode">"</span>"&nbsp;ident(x)&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">z</span>)</span> <span class="inlinecode">"</span>"&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span> <span class="inlinecode"></span>.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induction"&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident_list</span>(<span class="id" type="var">y</span>)</span> <span class="inlinecode">"</span>"&nbsp;ident(x)&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">z</span>)</span> <span class="inlinecode"><span class="id" type="var">ident</span></span> <span class="inlinecode">(<span class="id" type="var">w</span>)</span> <span class="inlinecode">"</span>"&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span>,</span> <span class="inlinecode"><span class="id" type="var">w</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span>,</span> <span class="inlinecode"><span class="id" type="var">w</span></span> <span class="inlinecode"></span>.<br/>
<br/>
<span class="comment">(**&nbsp;Versions&nbsp;with&nbsp;hacksimp&nbsp;*)</span><br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induct"&nbsp;ident(x)&nbsp;:=&nbsp;induction&nbsp;x;&nbsp;hacksimp.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induct"&nbsp;ident(x)&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">z</span>)</span> <span class="inlinecode">"</span>"&nbsp;:=&nbsp;<br/>
&nbsp;&nbsp;induction&nbsp;x;&nbsp;destruct&nbsp;z;&nbsp;hacksimp.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induct"&nbsp;ident(x)&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">z</span>)</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">w</span>)</span> <span class="inlinecode">"</span>"&nbsp;:=&nbsp;<br/>
&nbsp;&nbsp;induction&nbsp;x;&nbsp;destruct&nbsp;z,&nbsp;w;&nbsp;hacksimp.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induct"&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident_list</span>(<span class="id" type="var">y</span>)</span> <span class="inlinecode">"</span>"&nbsp;ident(x)&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="var">hacksimp</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="var">hacksimp</span></span> <span class="inlinecode"></span>.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induct"&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident_list</span>(<span class="id" type="var">y</span>)</span> <span class="inlinecode">"</span>"&nbsp;ident(x)&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">z</span>)</span> <span class="inlinecode">"</span>"&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span>;</span> <span class="inlinecode"><span class="id" type="var">hacksimp</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span>;</span> <span class="inlinecode"><span class="id" type="var">hacksimp</span></span> <span class="inlinecode"></span>.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"induct"&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident_list</span>(<span class="id" type="var">y</span>)</span> <span class="inlinecode">"</span>"&nbsp;ident(x)&nbsp;"<span class="inlinecode">"</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">z</span>)</span> <span class="inlinecode"><span class="id" type="var">ident</span>(<span class="id" type="var">w</span>)</span> <span class="inlinecode">"</span>"&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span>,</span> <span class="inlinecode"><span class="id" type="var">w</span>;</span> <span class="inlinecode"><span class="id" type="var">hacksimp</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="tactic">until</span></span> <span class="inlinecode"><span class="id" type="var">x</span>);</span> <span class="inlinecode"><span class="id" type="var">revert</span></span> <span class="inlinecode"><span class="id" type="var">y</span>;</span> <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">x</span>;</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">z</span>,</span> <span class="inlinecode"><span class="id" type="var">w</span>;</span> <span class="inlinecode"><span class="id" type="var">hacksimp</span></span> <span class="inlinecode"></span>.<br/>
<br/>
<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;*&nbsp;Views&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<br/>
Ltac&nbsp;vlib__apply_refl&nbsp;:=<br/>
&nbsp;&nbsp;intros;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;goal&nbsp;with&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|-&nbsp;is_true&nbsp;?p&nbsp;=&gt;&nbsp;eapply&nbsp;introT;&nbsp;<span class="inlinecode"><span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|-&nbsp;?p&nbsp;=&nbsp;true&nbsp;=&gt;&nbsp;eapply&nbsp;introT;&nbsp;<span class="inlinecode"><span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|-&nbsp;?p&nbsp;=&nbsp;false&nbsp;=&gt;&nbsp;eapply&nbsp;introFn;&nbsp;<span class="inlinecode"><span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|-&nbsp;?p&nbsp;=&nbsp;false&nbsp;=&gt;&nbsp;eapply&nbsp;introF;&nbsp;<span class="inlinecode"><span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]|</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;red;&nbsp;vlib__apply_refl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end.&nbsp;<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"apply"&nbsp;"/"&nbsp;:=&nbsp;vlib__apply_refl.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"apply"&nbsp;"/"&nbsp;constr(X)&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimT</span>;</span> <span class="inlinecode">[<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>|]</span>
    <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">introT</span>;</span> <span class="inlinecode">[<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>|]</span>
    <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">introFn</span>;</span> <span class="inlinecode">[<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>|]</span>
    <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">introF</span>;</span> <span class="inlinecode">[<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>|]</span>.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"split"&nbsp;"/"&nbsp;:=&nbsp;<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"><span class="id" type="tactic">split</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">hnf</span>;</span> <span class="inlinecode"><span class="id" type="tactic">intros</span>;</span> <span class="inlinecode"><span class="id" type="tactic">apply</span>/</span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" type="tactic">split</span></span>
        <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode"><span class="id" type="tactic">red</span>;</span> <span class="inlinecode"><span class="id" type="tactic">intros</span>;</span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">vlib__eqb_split</span></span>.<br/>
<br/>
<span class="comment">(**&nbsp;apply&nbsp;in&nbsp;assumption&nbsp;*)</span><br/>
<br/>
Ltac&nbsp;vlib__apply_refl_in&nbsp;H&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimT</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span>;</span> <span class="inlinecode">[|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]]</span>
        <span class="inlinecode">|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimFn</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span>;</span> <span class="inlinecode">[|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]]</span>
        <span class="inlinecode">|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimF</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span>;</span> <span class="inlinecode">[|<span class="id" type="tactic">solve</span></span> <span class="inlinecode">[<span class="id" type="tactic">trivial</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode"><span class="id" type="var">vlib_refl</span>]]</span>.<br/>
<br/>
Ltac&nbsp;vlib__apply_with_in&nbsp;X&nbsp;H&nbsp;:=<br/>
&nbsp;&nbsp;first&nbsp;<span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>
        <span class="inlinecode">|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimT</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span>;</span> <span class="inlinecode">[|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>]</span>
        <span class="inlinecode">|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimFn</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span>;</span> <span class="inlinecode">[|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>]</span>
        <span class="inlinecode">|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">elimF</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span>;</span> <span class="inlinecode">[|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">X</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>]</span>.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"apply"&nbsp;"/"&nbsp;"in"&nbsp;hyp(H)&nbsp;:=&nbsp;vlib__apply_refl_in&nbsp;H.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"apply"&nbsp;"/"&nbsp;constr(X)&nbsp;"in"&nbsp;hyp(H)&nbsp;:=&nbsp;vlib__apply_with_in&nbsp;X&nbsp;H.<br/>
<br/>
<span class="comment">(**&nbsp;move&nbsp;(apply&nbsp;to&nbsp;top&nbsp;of&nbsp;goal)&nbsp;*)</span><br/>
<br/>
Ltac&nbsp;vlib__move_refl&nbsp;:=&nbsp;let&nbsp;top&nbsp;:=&nbsp;fresh&nbsp;in&nbsp;intro&nbsp;top;&nbsp;vlib__apply_refl_in&nbsp;top;&nbsp;revert&nbsp;top.&nbsp;<br/>
Ltac&nbsp;vlib__move_with&nbsp;X&nbsp;:=&nbsp;let&nbsp;top&nbsp;:=&nbsp;fresh&nbsp;in&nbsp;intro&nbsp;top;&nbsp;vlib__apply_with_in&nbsp;X&nbsp;top;&nbsp;revert&nbsp;top.&nbsp;<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;intros&nbsp;L.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;":"&nbsp;ident_list(Y)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;":"&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;intros&nbsp;L.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"<br/>
&nbsp;&nbsp;:=&nbsp;vlib__move_refl.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;":"&nbsp;ident_list(Y)&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__move_refl.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;vlib__move_refl;&nbsp;intros&nbsp;L.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;":"&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__move_refl;&nbsp;intros&nbsp;L.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;constr(X)&nbsp;ident_list(Y)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__move_with&nbsp;X.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;constr(X)&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__move_with&nbsp;X;&nbsp;intros&nbsp;L.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;constr(X)&nbsp;":"&nbsp;ident_list(Y)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__move_with&nbsp;X.<br/>
Tactic&nbsp;Notation&nbsp;"move"&nbsp;"/"&nbsp;constr(X)&nbsp;":"&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__move_with&nbsp;X;&nbsp;intros&nbsp;L.<br/>
<br/>
<br/>
<span class="comment">(**&nbsp;case&nbsp;*)</span><br/>
<br/>
Ltac&nbsp;vlib__case_plain<br/>
&nbsp;&nbsp;:=&nbsp;let&nbsp;top&nbsp;:=&nbsp;fresh&nbsp;in&nbsp;intro&nbsp;top;&nbsp;case&nbsp;top;&nbsp;clear&nbsp;top.<br/>
Ltac&nbsp;vlib__case_refl<br/>
&nbsp;&nbsp;:=&nbsp;let&nbsp;top&nbsp;:=&nbsp;fresh&nbsp;in&nbsp;intro&nbsp;top;&nbsp;vlib__apply_refl_in&nbsp;top;&nbsp;case&nbsp;top;&nbsp;clear&nbsp;top.&nbsp;<br/>
Ltac&nbsp;vlib__case_with&nbsp;X&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;let&nbsp;top&nbsp;:=&nbsp;fresh&nbsp;in&nbsp;intro&nbsp;top;&nbsp;vlib__apply_with_in&nbsp;X&nbsp;top;&nbsp;case&nbsp;top;&nbsp;clear&nbsp;top.&nbsp;<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;vlib__case_plain;&nbsp;intros&nbsp;L.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;":"&nbsp;ident_list(Y)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_plain.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;":"&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_plain;&nbsp;intros&nbsp;L.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"<br/>
&nbsp;&nbsp;:=&nbsp;vlib__case_refl.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;":"&nbsp;ident_list(Y)&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_refl.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;vlib__case_refl;&nbsp;intros&nbsp;L.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;":"&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)&nbsp;<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_refl;&nbsp;intros&nbsp;L.<br/>
<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;constr(X)&nbsp;ident_list(Y)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_with&nbsp;X.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;constr(X)&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_with&nbsp;X;&nbsp;intros&nbsp;L.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;constr(X)&nbsp;":"&nbsp;ident_list(Y)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_with&nbsp;X.<br/>
Tactic&nbsp;Notation&nbsp;"case"&nbsp;"/"&nbsp;constr(X)&nbsp;":"&nbsp;ident_list(Y)&nbsp;"=&gt;"&nbsp;simple_intropattern_list(L)<br/>
&nbsp;&nbsp;:=&nbsp;revert&nbsp;Y;&nbsp;vlib__case_with&nbsp;X;&nbsp;intros&nbsp;L.<br/>
<br/>
<span class="comment">(**&nbsp;double&nbsp;apply&nbsp;*)</span><br/>
<br/>
Tactic&nbsp;Notation&nbsp;"apply"&nbsp;"/"&nbsp;constr(X1)&nbsp;"/"&nbsp;constr(X2)&nbsp;:=<br/>
&nbsp;&nbsp;eapply&nbsp;sameP;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">X1</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>|<span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">iffP</span>;</span> <span class="inlinecode">[<span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">X2</span>;</span> <span class="inlinecode"><span class="id" type="var">edone</span>|<span class="id" type="tactic">instantiate</span>|<span class="id" type="tactic">instantiate</span>]</span>.<br/>
<br/>
<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;*&nbsp;Function&nbsp;notation&nbsp;ported&nbsp;from&nbsp;ssrfun.v&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<br/>
Delimit&nbsp;Scope&nbsp;fun_scope&nbsp;with&nbsp;FUN.<br/>
Open&nbsp;Scope&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"f&nbsp;^~&nbsp;y"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;f&nbsp;x&nbsp;y)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;10,&nbsp;y&nbsp;at&nbsp;level&nbsp;8,&nbsp;no&nbsp;associativity,&nbsp;format&nbsp;"f&nbsp;^~&nbsp;&nbsp;y")&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Module&nbsp;Option.<br/>
<br/>
Definition&nbsp;apply&nbsp;aT&nbsp;rT&nbsp;(f&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;rT)&nbsp;x&nbsp;u&nbsp;:=&nbsp;<br/>
&nbsp;&nbsp;match&nbsp;u&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;y&nbsp;=&gt;&nbsp;f&nbsp;y&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;=&gt;&nbsp;x<br/>
&nbsp;&nbsp;end.<br/>
<br/>
Definition&nbsp;default&nbsp;T&nbsp;:=&nbsp;apply&nbsp;(fun&nbsp;x&nbsp;:&nbsp;T&nbsp;=&gt;&nbsp;x).<br/>
<br/>
Definition&nbsp;bind&nbsp;aT&nbsp;rT&nbsp;(f&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;option&nbsp;rT)&nbsp;:=&nbsp;apply&nbsp;f&nbsp;None.<br/>
<br/>
Definition&nbsp;map&nbsp;aT&nbsp;rT&nbsp;(f&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;rT)&nbsp;:=&nbsp;bind&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;Some&nbsp;(f&nbsp;x)).<br/>
<br/>
End&nbsp;Option.<br/>
<br/>
Notation&nbsp;oapp&nbsp;:=&nbsp;Option.apply.<br/>
Notation&nbsp;odflt&nbsp;:=&nbsp;Option.default.<br/>
Notation&nbsp;obind&nbsp;:=&nbsp;Option.bind.<br/>
Notation&nbsp;omap&nbsp;:=&nbsp;Option.map.<br/>
Notation&nbsp;some&nbsp;:=&nbsp;(@Some&nbsp;_)&nbsp;(only&nbsp;parsing).<br/>
<br/>
<span class="comment">(**&nbsp;Definitions&nbsp;and&nbsp;notation&nbsp;for&nbsp;explicit&nbsp;functions&nbsp;with&nbsp;simplification.&nbsp;*)</span><br/>
<br/>
Section&nbsp;SimplFun.<br/>
<br/>
Variables&nbsp;aT&nbsp;rT&nbsp;:&nbsp;Type.<br/>
<br/>
Inductive&nbsp;simpl_fun&nbsp;:&nbsp;Type&nbsp;:=&nbsp;SimplFun&nbsp;(_&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;rT).<br/>
<br/>
Definition&nbsp;fun_of_simpl&nbsp;:=&nbsp;fun&nbsp;f&nbsp;x&nbsp;=&gt;&nbsp;match&nbsp;f&nbsp;with&nbsp;SimplFun&nbsp;lam&nbsp;=&gt;&nbsp;lam&nbsp;x&nbsp;end.&nbsp;<br/>
<br/>
Coercion&nbsp;fun_of_simpl&nbsp;:&nbsp;simpl_fun&nbsp;&gt;-&gt;&nbsp;Funclass.<br/>
<br/>
End&nbsp;SimplFun.<br/>
<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(SimplFun&nbsp;(fun&nbsp;_&nbsp;:&nbsp;T&nbsp;=&gt;&nbsp;E))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"'<span class="inlinecode"><span class="id" type="var">hv'</span></span> <span class="inlinecode">[</span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode">:</span>  <span class="inlinecode"><span class="id" type="var">T</span></span>  <span class="inlinecode">=&gt;</span> <span class="inlinecode">'/</span> <span class="inlinecode">'</span>  <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode">]</span> <span class="inlinecode">'</span>'")&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(SimplFun&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;E))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"'<span class="inlinecode"><span class="id" type="var">hv'</span></span> <span class="inlinecode">[</span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span>  <span class="inlinecode"><span class="id" type="var">x</span></span>  <span class="inlinecode">=&gt;</span> <span class="inlinecode">'/</span> <span class="inlinecode">'</span>  <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode">]</span> <span class="inlinecode">'</span>'")&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(SimplFun&nbsp;(fun&nbsp;x&nbsp;:&nbsp;T&nbsp;=&gt;&nbsp;E))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,&nbsp;only&nbsp;parsing)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;<span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span>)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"'<span class="inlinecode"><span class="id" type="var">hv'</span></span> <span class="inlinecode">[</span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span>  <span class="inlinecode"><span class="id" type="var">x</span></span>  <span class="inlinecode"><span class="id" type="var">y</span></span>  <span class="inlinecode">=&gt;</span> <span class="inlinecode">'/</span> <span class="inlinecode">'</span>  <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode">]</span> <span class="inlinecode">'</span>'")&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;:&nbsp;T&nbsp;=&gt;&nbsp;<span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span>)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,&nbsp;only&nbsp;parsing)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode">(</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">)</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;:&nbsp;T&nbsp;=&gt;&nbsp;<span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span>)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,&nbsp;only&nbsp;parsing)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">(</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;<span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span>)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,&nbsp;only&nbsp;parsing)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">fun'</span></span> <span class="inlinecode">(</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">xT</span></span> <span class="inlinecode">)</span> <span class="inlinecode">(</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">yT</span></span> <span class="inlinecode">)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode"></span>"&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;x&nbsp;:&nbsp;xT&nbsp;=&gt;&nbsp;<span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">yT</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">E</span></span>)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,&nbsp;only&nbsp;parsing)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Definition&nbsp;erefl&nbsp;:=&nbsp;@eq_refl.<br/>
Definition&nbsp;esym&nbsp;:=&nbsp;eq_sym.<br/>
Definition&nbsp;nesym&nbsp;:=&nbsp;sym_not_eq.<br/>
Definition&nbsp;etrans&nbsp;:=&nbsp;eq_trans.<br/>
Definition&nbsp;congr1&nbsp;:=&nbsp;f_equal.<br/>
Definition&nbsp;congr2&nbsp;:=&nbsp;f_equal2.<br/>
<br/>
<span class="comment">(**&nbsp;A&nbsp;predicate&nbsp;for&nbsp;singleton&nbsp;types.&nbsp;*)</span><br/>
Definition&nbsp;all_equal_to&nbsp;T&nbsp;(x0&nbsp;:&nbsp;T)&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;x&nbsp;=&nbsp;x0.<br/>
<br/>
Lemma&nbsp;unitE&nbsp;:&nbsp;all_equal_to&nbsp;tt.<br/>
Proof.&nbsp;by&nbsp;intros&nbsp;<span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
<span class="comment">(**&nbsp;A&nbsp;generic&nbsp;wrapper&nbsp;type&nbsp;*)</span><br/>
<br/>
Structure&nbsp;wrapped&nbsp;T&nbsp;:=&nbsp;Wrap&nbsp;{unwrap&nbsp;:&nbsp;T}.<br/>
Canonical&nbsp;Structure&nbsp;wrap&nbsp;T&nbsp;x&nbsp;:=&nbsp;@Wrap&nbsp;T&nbsp;x.<br/>
<br/>
<span class="comment">(*&nbsp;Prenex&nbsp;Implicits&nbsp;unwrap&nbsp;wrap&nbsp;Wrap.&nbsp;*)</span><br/>
<br/>
<span class="comment">(**&nbsp;Extensional&nbsp;equality&nbsp;for&nbsp;unary&nbsp;and&nbsp;binary&nbsp;functions&nbsp;+&nbsp;syntactic&nbsp;sugar.&nbsp;*)</span><br/>
<br/>
Section&nbsp;ExtensionalEquality.<br/>
<br/>
Variables&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Type.<br/>
<br/>
Definition&nbsp;eqfun&nbsp;(f&nbsp;g&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A)&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x.<br/>
<br/>
Definition&nbsp;eqrel&nbsp;(r&nbsp;s&nbsp;:&nbsp;C&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A)&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;forall&nbsp;x&nbsp;y,&nbsp;r&nbsp;x&nbsp;y&nbsp;=&nbsp;s&nbsp;x&nbsp;y.<br/>
<br/>
Lemma&nbsp;frefl&nbsp;:&nbsp;forall&nbsp;f,&nbsp;eqfun&nbsp;f&nbsp;f.<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;fsym&nbsp;:&nbsp;forall&nbsp;f&nbsp;g,&nbsp;eqfun&nbsp;f&nbsp;g&nbsp;-&gt;&nbsp;eqfun&nbsp;g&nbsp;f.<br/>
Proof.&nbsp;red;&nbsp;done.&nbsp;Qed.&nbsp;<br/>
<br/>
Lemma&nbsp;ftrans&nbsp;:&nbsp;forall&nbsp;f&nbsp;g&nbsp;h&nbsp;(EQ1:&nbsp;eqfun&nbsp;f&nbsp;g)&nbsp;(EQ2:&nbsp;eqfun&nbsp;g&nbsp;h),&nbsp;eqfun&nbsp;f&nbsp;h.<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;intros;&nbsp;rewrite&nbsp;EQ1.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;rrefl&nbsp;:&nbsp;forall&nbsp;r,&nbsp;eqrel&nbsp;r&nbsp;r.<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
<br/>
End&nbsp;ExtensionalEquality.<br/>
<br/>
Hint&nbsp;Resolve&nbsp;frefl&nbsp;rrefl.<br/>
<br/>
Notation&nbsp;"f1&nbsp;=1&nbsp;f2"&nbsp;:=&nbsp;(eqfun&nbsp;f1&nbsp;f2)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;70,&nbsp;no&nbsp;associativity)&nbsp;:&nbsp;fun_scope.<br/>
Notation&nbsp;"f1&nbsp;=1&nbsp;f2&nbsp;:&gt;&nbsp;A"&nbsp;:=&nbsp;(f1&nbsp;=1&nbsp;(f2&nbsp;:&nbsp;A))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;70,&nbsp;f2&nbsp;at&nbsp;next&nbsp;level,&nbsp;A&nbsp;at&nbsp;level&nbsp;90)&nbsp;:&nbsp;fun_scope.<br/>
Notation&nbsp;"f1&nbsp;=2&nbsp;f2"&nbsp;:=&nbsp;(eqrel&nbsp;f1&nbsp;f2)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;70,&nbsp;no&nbsp;associativity)&nbsp;:&nbsp;fun_scope.<br/>
Notation&nbsp;"f1&nbsp;=2&nbsp;f2&nbsp;:&gt;&nbsp;A"&nbsp;:=&nbsp;(f1&nbsp;=2&nbsp;(f2&nbsp;:&nbsp;A))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;70,&nbsp;f2&nbsp;at&nbsp;next&nbsp;level,&nbsp;A,&nbsp;B&nbsp;at&nbsp;level&nbsp;90)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Section&nbsp;Composition.<br/>
<br/>
Variables&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Type.<br/>
<br/>
Definition&nbsp;funcomp&nbsp;u&nbsp;(f&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A)&nbsp;(g&nbsp;:&nbsp;C&nbsp;-&gt;&nbsp;B)&nbsp;x&nbsp;:=&nbsp;match&nbsp;u&nbsp;with&nbsp;tt&nbsp;=&gt;&nbsp;f&nbsp;(g&nbsp;x)&nbsp;end.<br/>
Local&nbsp;Notation&nbsp;comp&nbsp;:=&nbsp;(funcomp&nbsp;tt).<br/>
<br/>
Definition&nbsp;pcomp&nbsp;(f&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;option&nbsp;A)&nbsp;(g&nbsp;:&nbsp;C&nbsp;-&gt;&nbsp;option&nbsp;B)&nbsp;x&nbsp;:=&nbsp;obind&nbsp;f&nbsp;(g&nbsp;x).<br/>
<br/>
Lemma&nbsp;eq_comp&nbsp;:&nbsp;forall&nbsp;f&nbsp;f'&nbsp;g&nbsp;g',&nbsp;f&nbsp;=1&nbsp;f'&nbsp;-&gt;&nbsp;g&nbsp;=1&nbsp;g'&nbsp;-&gt;&nbsp;comp&nbsp;f&nbsp;g&nbsp;=1&nbsp;comp&nbsp;f'&nbsp;g'.<br/>
Proof.&nbsp;red;&nbsp;intros;&nbsp;simpl;&nbsp;congruence.&nbsp;Qed.<br/>
<br/>
End&nbsp;Composition.<br/>
<br/>
Notation&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">eta'</span></span> <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"></span>"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;f&nbsp;x)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;format&nbsp;"<span class="inlinecode"></span> <span class="inlinecode">'<span class="id" type="var">eta'</span></span>  <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"></span>")&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;id&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;x).<br/>
Notation&nbsp;"@&nbsp;'id'&nbsp;T&nbsp;"&nbsp;:=&nbsp;(fun&nbsp;x&nbsp;:&nbsp;T&nbsp;=&gt;&nbsp;x)<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;10,&nbsp;T&nbsp;at&nbsp;level&nbsp;8,&nbsp;only&nbsp;parsing)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Notation&nbsp;comp&nbsp;:=&nbsp;(funcomp&nbsp;tt).<br/>
Notation&nbsp;"@&nbsp;'comp'"&nbsp;:=&nbsp;(fun&nbsp;A&nbsp;B&nbsp;C&nbsp;=&gt;&nbsp;@funcomp&nbsp;A&nbsp;B&nbsp;C&nbsp;tt).<br/>
Notation&nbsp;"f1&nbsp;\o&nbsp;f2"&nbsp;:=&nbsp;(comp&nbsp;f1&nbsp;f2)&nbsp;(at&nbsp;level&nbsp;50)&nbsp;:&nbsp;fun_scope.<br/>
<br/>
Section&nbsp;Morphism.<br/>
<br/>
Variables&nbsp;(aT&nbsp;rT&nbsp;sT&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;rT).<br/>
<br/>
Definition&nbsp;morphism_1&nbsp;aF&nbsp;rF&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;f&nbsp;(aF&nbsp;x)&nbsp;=&nbsp;rF&nbsp;(f&nbsp;x).<br/>
Definition&nbsp;morphism_2&nbsp;aOp&nbsp;rOp&nbsp;:=&nbsp;forall&nbsp;x&nbsp;y,&nbsp;f&nbsp;(aOp&nbsp;x&nbsp;y)&nbsp;=&nbsp;rOp&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;y).<br/>
<br/>
End&nbsp;Morphism.<br/>
<br/>
Notation&nbsp;"{&nbsp;'morph'&nbsp;f&nbsp;:&nbsp;x&nbsp;/&nbsp;a&nbsp;&gt;-&gt;&nbsp;r&nbsp;}"&nbsp;:=<br/>
&nbsp;&nbsp;(morphism_1&nbsp;f&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;a)&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;r))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;f&nbsp;at&nbsp;level&nbsp;99,&nbsp;x&nbsp;ident,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"{&nbsp;'morph'&nbsp;&nbsp;f&nbsp;&nbsp;:&nbsp;&nbsp;x&nbsp;&nbsp;/&nbsp;&nbsp;a&nbsp;&nbsp;&gt;-&gt;&nbsp;&nbsp;r&nbsp;}")&nbsp;:&nbsp;type_scope.<br/>
<br/>
Notation&nbsp;"{&nbsp;'morph'&nbsp;f&nbsp;:&nbsp;x&nbsp;/&nbsp;a&nbsp;}"&nbsp;:=<br/>
&nbsp;&nbsp;(morphism_1&nbsp;f&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;a)&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;a))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;f&nbsp;at&nbsp;level&nbsp;99,&nbsp;x&nbsp;ident,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"{&nbsp;'morph'&nbsp;&nbsp;f&nbsp;&nbsp;:&nbsp;&nbsp;x&nbsp;&nbsp;/&nbsp;&nbsp;a&nbsp;}")&nbsp;:&nbsp;type_scope.<br/>
<br/>
Notation&nbsp;"{&nbsp;'morph'&nbsp;f&nbsp;:&nbsp;x&nbsp;y&nbsp;/&nbsp;a&nbsp;&gt;-&gt;&nbsp;r&nbsp;}"&nbsp;:=<br/>
&nbsp;&nbsp;(morphism_2&nbsp;f&nbsp;(fun&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;a)&nbsp;(fun&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;r))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;f&nbsp;at&nbsp;level&nbsp;99,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"{&nbsp;'morph'&nbsp;&nbsp;f&nbsp;&nbsp;:&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;/&nbsp;&nbsp;a&nbsp;&nbsp;&gt;-&gt;&nbsp;&nbsp;r&nbsp;}")&nbsp;:&nbsp;type_scope.<br/>
<br/>
Notation&nbsp;"{&nbsp;'morph'&nbsp;f&nbsp;:&nbsp;x&nbsp;y&nbsp;/&nbsp;a&nbsp;}"&nbsp;:=<br/>
&nbsp;&nbsp;(morphism_2&nbsp;f&nbsp;(fun&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;a)&nbsp;(fun&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;a))<br/>
&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;f&nbsp;at&nbsp;level&nbsp;99,&nbsp;x&nbsp;ident,&nbsp;y&nbsp;ident,<br/>
&nbsp;&nbsp;&nbsp;format&nbsp;"{&nbsp;'morph'&nbsp;&nbsp;f&nbsp;&nbsp;:&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;/&nbsp;&nbsp;a&nbsp;}")&nbsp;:&nbsp;type_scope.<br/>
<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;*&nbsp;Properties&nbsp;of&nbsp;relations&nbsp;(ported&nbsp;from&nbsp;ssrfun.v)&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<br/>
Section&nbsp;Injections.<br/>
<br/>
<span class="comment">(*&nbsp;rT&nbsp;must&nbsp;come&nbsp;first&nbsp;so&nbsp;we&nbsp;can&nbsp;use&nbsp;@&nbsp;to&nbsp;mitigate&nbsp;the&nbsp;Coq&nbsp;1st&nbsp;order&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;unification&nbsp;bug&nbsp;(e..g.,&nbsp;Coq&nbsp;can't&nbsp;infer&nbsp;rT&nbsp;from&nbsp;a&nbsp;"cancel"&nbsp;lemma).&nbsp;*)</span><br/>
Variables&nbsp;(rT&nbsp;aT&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;rT).<br/>
<br/>
Definition&nbsp;injective&nbsp;:=&nbsp;forall&nbsp;x1&nbsp;x2,&nbsp;f&nbsp;x1&nbsp;=&nbsp;f&nbsp;x2&nbsp;-&gt;&nbsp;x1&nbsp;=&nbsp;x2.<br/>
<br/>
Definition&nbsp;cancel&nbsp;g&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;g&nbsp;(f&nbsp;x)&nbsp;=&nbsp;x.<br/>
<br/>
Definition&nbsp;pcancel&nbsp;g&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;g&nbsp;(f&nbsp;x)&nbsp;=&nbsp;Some&nbsp;x.<br/>
<br/>
Definition&nbsp;ocancel&nbsp;(g&nbsp;:&nbsp;aT&nbsp;-&gt;&nbsp;option&nbsp;rT)&nbsp;h&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;oapp&nbsp;h&nbsp;x&nbsp;(g&nbsp;x)&nbsp;=&nbsp;x.<br/>
<br/>
Lemma&nbsp;can_pcan&nbsp;:&nbsp;forall&nbsp;g,&nbsp;cancel&nbsp;g&nbsp;-&gt;&nbsp;pcancel&nbsp;(fun&nbsp;y&nbsp;=&gt;&nbsp;Some&nbsp;(g&nbsp;y)).<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;intros;&nbsp;f_equal.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;pcan_inj&nbsp;:&nbsp;forall&nbsp;g,&nbsp;pcancel&nbsp;g&nbsp;-&gt;&nbsp;injective.<br/>
Proof.&nbsp;red;&nbsp;intros;&nbsp;apply&nbsp;(congr1&nbsp;g)&nbsp;in&nbsp;H0;&nbsp;rewrite&nbsp;!H&nbsp;in&nbsp;*;&nbsp;clarify.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;can_inj&nbsp;:&nbsp;forall&nbsp;g,&nbsp;cancel&nbsp;g&nbsp;-&gt;&nbsp;injective.<br/>
Proof.&nbsp;eby&nbsp;intros;&nbsp;apply&nbsp;can_pcan&nbsp;in&nbsp;H;&nbsp;eapply&nbsp;pcan_inj.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;canLR&nbsp;:&nbsp;forall&nbsp;g&nbsp;x&nbsp;y,&nbsp;cancel&nbsp;g&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;f&nbsp;y&nbsp;-&gt;&nbsp;g&nbsp;x&nbsp;=&nbsp;y.<br/>
Proof.&nbsp;intros;&nbsp;clarify.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;canRL&nbsp;:&nbsp;forall&nbsp;g&nbsp;x&nbsp;y,&nbsp;cancel&nbsp;g&nbsp;-&gt;&nbsp;f&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;g&nbsp;y.<br/>
Proof.&nbsp;intros;&nbsp;clarify.&nbsp;Qed.&nbsp;<br/>
<br/>
End&nbsp;Injections.<br/>
<br/>
<span class="comment">(*&nbsp;cancellation&nbsp;lemmas&nbsp;for&nbsp;dependent&nbsp;type&nbsp;casts.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
Lemma&nbsp;esymK&nbsp;:&nbsp;forall&nbsp;T&nbsp;x&nbsp;y,&nbsp;cancel&nbsp;(@eq_sym&nbsp;T&nbsp;x&nbsp;y)&nbsp;(@eq_sym&nbsp;T&nbsp;y&nbsp;x).<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;destruct&nbsp;x0.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;etrans_id&nbsp;:&nbsp;forall&nbsp;T&nbsp;x&nbsp;y&nbsp;(eqxy&nbsp;:&nbsp;x&nbsp;=&nbsp;y&nbsp;:&gt;&nbsp;T),<br/>
&nbsp;&nbsp;eq_trans&nbsp;(eq_refl&nbsp;x)&nbsp;eqxy&nbsp;=&nbsp;eqxy.<br/>
Proof.&nbsp;by&nbsp;destruct&nbsp;eqxy.&nbsp;Qed.<br/>
<br/>
Section&nbsp;InjectionsTheory.<br/>
<br/>
Variables&nbsp;(A&nbsp;B&nbsp;C&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;g&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A)&nbsp;(h&nbsp;:&nbsp;C&nbsp;-&gt;&nbsp;B).<br/>
<br/>
Lemma&nbsp;inj_id&nbsp;:&nbsp;injective&nbsp;(@id&nbsp;A).<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;inj_can_sym&nbsp;:&nbsp;forall&nbsp;f',&nbsp;cancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;injective&nbsp;f'&nbsp;-&gt;&nbsp;cancel&nbsp;f'&nbsp;f.<br/>
Proof.&nbsp;red;&nbsp;intros;&nbsp;apply&nbsp;H0,&nbsp;H.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;inj_comp&nbsp;:&nbsp;injective&nbsp;f&nbsp;-&gt;&nbsp;injective&nbsp;h&nbsp;-&gt;&nbsp;injective&nbsp;(f&nbsp;\o&nbsp;h).<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;simpl;&nbsp;intros;&nbsp;apply&nbsp;H0,&nbsp;H.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;can_comp&nbsp;:&nbsp;forall&nbsp;f'&nbsp;h',<br/>
&nbsp;&nbsp;cancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;cancel&nbsp;h&nbsp;h'&nbsp;-&gt;&nbsp;cancel&nbsp;(f&nbsp;\o&nbsp;h)&nbsp;(h'&nbsp;\o&nbsp;f').<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;simpl;&nbsp;intros;&nbsp;rewrite&nbsp;H,&nbsp;H0.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;pcan_pcomp&nbsp;:&nbsp;forall&nbsp;f'&nbsp;h',<br/>
&nbsp;&nbsp;pcancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;pcancel&nbsp;h&nbsp;h'&nbsp;-&gt;&nbsp;pcancel&nbsp;(f&nbsp;\o&nbsp;h)&nbsp;(pcomp&nbsp;h'&nbsp;f').<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;intros;&nbsp;unfold&nbsp;pcomp;&nbsp;simpl;&nbsp;rewrite&nbsp;H;&nbsp;simpl;&nbsp;rewrite&nbsp;H0.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;eq_inj&nbsp;:&nbsp;injective&nbsp;f&nbsp;-&gt;&nbsp;f&nbsp;=1&nbsp;g&nbsp;-&gt;&nbsp;injective&nbsp;g.<br/>
Proof.&nbsp;intros&nbsp;H&nbsp;H0&nbsp;x&nbsp;y;&nbsp;simpl;&nbsp;rewrite&nbsp;&lt;-&nbsp;!H0;&nbsp;apply&nbsp;H.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;eq_can&nbsp;:&nbsp;forall&nbsp;f'&nbsp;g',&nbsp;cancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;f&nbsp;=1&nbsp;g&nbsp;-&gt;&nbsp;f'&nbsp;=1&nbsp;g'&nbsp;-&gt;&nbsp;cancel&nbsp;g&nbsp;g'.<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;intros;&nbsp;rewrite&nbsp;&lt;-&nbsp;H0,&nbsp;&lt;-&nbsp;H1.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;inj_can_eq&nbsp;:&nbsp;forall&nbsp;f',<br/>
&nbsp;&nbsp;cancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;injective&nbsp;f'&nbsp;-&gt;&nbsp;cancel&nbsp;g&nbsp;f'&nbsp;-&gt;&nbsp;f&nbsp;=1&nbsp;g.<br/>
Proof.&nbsp;by&nbsp;red;&nbsp;intros;&nbsp;apply&nbsp;H0;&nbsp;rewrite&nbsp;H1.&nbsp;Qed.<br/>
<br/>
End&nbsp;InjectionsTheory.<br/>
<br/>
Section&nbsp;Bijections.<br/>
<br/>
Variables&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A).<br/>
<br/>
Inductive&nbsp;bijective&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;Bijective&nbsp;g&nbsp;(_&nbsp;:&nbsp;cancel&nbsp;f&nbsp;g)&nbsp;(_&nbsp;:&nbsp;cancel&nbsp;g&nbsp;f).<br/>
<br/>
Hypothesis&nbsp;bijf&nbsp;:&nbsp;bijective.<br/>
<br/>
Lemma&nbsp;bij_inj&nbsp;:&nbsp;injective&nbsp;f.<br/>
Proof.&nbsp;eby&nbsp;destruct&nbsp;bijf;&nbsp;eapply&nbsp;can_inj.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;bij_can_sym&nbsp;:&nbsp;forall&nbsp;f',&nbsp;cancel&nbsp;f'&nbsp;f&nbsp;&lt;-&gt;&nbsp;cancel&nbsp;f&nbsp;f'.<br/>
Proof.<br/>
split;&nbsp;intros;&nbsp;<span class="inlinecode"><span class="id" type="tactic">by</span></span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">inj_can_sym</span>,</span> <span class="inlinecode"><span class="id" type="var">bij_inj</span>|</span>.<br/>
by&nbsp;destruct&nbsp;bijf;&nbsp;intros&nbsp;x;&nbsp;rewrite&nbsp;&lt;-&nbsp;(H1&nbsp;x),&nbsp;H.<br/>
Qed.<br/>
<br/>
Lemma&nbsp;bij_can_eq&nbsp;:&nbsp;forall&nbsp;f'&nbsp;f'',&nbsp;cancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;cancel&nbsp;f&nbsp;f''&nbsp;-&gt;&nbsp;f'&nbsp;=1&nbsp;f''.<br/>
Proof.<br/>
&nbsp;&nbsp;by&nbsp;intros;&nbsp;eapply&nbsp;inj_can_eq,&nbsp;bij_can_sym;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">bij_can_sym</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">bij_inj</span></span> <span class="inlinecode">|</span>.<br/>
Qed.<br/>
<br/>
End&nbsp;Bijections.<br/>
<br/>
Section&nbsp;BijectionsTheory.<br/>
<br/>
Variables&nbsp;(A&nbsp;B&nbsp;C&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A)&nbsp;(h&nbsp;:&nbsp;C&nbsp;-&gt;&nbsp;B).<br/>
<br/>
Lemma&nbsp;eq_bij&nbsp;:&nbsp;bijective&nbsp;f&nbsp;-&gt;&nbsp;forall&nbsp;g,&nbsp;f&nbsp;=1&nbsp;g&nbsp;-&gt;&nbsp;bijective&nbsp;g.<br/>
Proof.&nbsp;by&nbsp;destruct&nbsp;1;&nbsp;exists&nbsp;g;&nbsp;eapply&nbsp;eq_can;&nbsp;eauto.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;bij_comp&nbsp;:&nbsp;bijective&nbsp;f&nbsp;-&gt;&nbsp;bijective&nbsp;h&nbsp;-&gt;&nbsp;bijective&nbsp;(f&nbsp;\o&nbsp;h).<br/>
Proof.<br/>
intros&nbsp;<span class="inlinecode"><span class="id" type="var">f'</span></span> <span class="inlinecode"><span class="id" type="var">fK</span></span> <span class="inlinecode"><span class="id" type="var">f'K</span></span>&nbsp;<span class="inlinecode"><span class="id" type="var">h'</span></span> <span class="inlinecode"><span class="id" type="var">hK</span></span> <span class="inlinecode"><span class="id" type="var">h'K</span></span>.<br/>
by&nbsp;exists&nbsp;(h'&nbsp;\o&nbsp;f'&nbsp;:&nbsp;_&nbsp;-&gt;&nbsp;_);&nbsp;apply&nbsp;can_comp;&nbsp;auto.<br/>
Qed.<br/>
<br/>
Lemma&nbsp;bij_can_bij&nbsp;:&nbsp;bijective&nbsp;f&nbsp;-&gt;&nbsp;forall&nbsp;f',&nbsp;cancel&nbsp;f&nbsp;f'&nbsp;-&gt;&nbsp;bijective&nbsp;f'.<br/>
Proof.&nbsp;by&nbsp;exists&nbsp;f;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode">(<span class="id" type="var">bij_can_sym</span></span> <span class="inlinecode"><span class="id" type="var">H</span>)</span> <span class="inlinecode">|</span>.&nbsp;Qed.<br/>
<br/>
End&nbsp;BijectionsTheory.<br/>
<br/>
Section&nbsp;Involutions.<br/>
<br/>
Variables&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A).<br/>
<br/>
Definition&nbsp;involutive&nbsp;:=&nbsp;cancel&nbsp;f&nbsp;f.<br/>
<br/>
Hypothesis&nbsp;Hf&nbsp;:&nbsp;involutive.<br/>
<br/>
Lemma&nbsp;inv_inj&nbsp;:&nbsp;injective&nbsp;f.<br/>
Proof.&nbsp;eapply&nbsp;can_inj,&nbsp;Hf.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;inv_bij&nbsp;:&nbsp;bijective&nbsp;f.<br/>
Proof.&nbsp;by&nbsp;exists&nbsp;f.&nbsp;Qed.<br/>
<br/>
End&nbsp;Involutions.<br/>
<br/>
<br/>
Section&nbsp;OperationProperties.<br/>
<br/>
Variables&nbsp;S&nbsp;T&nbsp;R&nbsp;:&nbsp;Type.<br/>
<br/>
Section&nbsp;SopTisR.<br/>
Implicit&nbsp;Type&nbsp;op&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;T&nbsp;-&gt;&nbsp;R.<br/>
Definition&nbsp;left_inverse&nbsp;e&nbsp;inv&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;(inv&nbsp;x)&nbsp;x&nbsp;=&nbsp;e.<br/>
Definition&nbsp;right_inverse&nbsp;e&nbsp;inv&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;x&nbsp;(inv&nbsp;x)&nbsp;=&nbsp;e.<br/>
End&nbsp;SopTisR.<br/>
<br/>
Section&nbsp;SopTisS.<br/>
Implicit&nbsp;Type&nbsp;op&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;T&nbsp;-&gt;&nbsp;S.<br/>
Definition&nbsp;right_id&nbsp;e&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;x&nbsp;e&nbsp;=&nbsp;x.<br/>
Definition&nbsp;left_zero&nbsp;z&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;z&nbsp;x&nbsp;=&nbsp;z.<br/>
Definition&nbsp;right_commutative&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;op&nbsp;(op&nbsp;x&nbsp;y)&nbsp;z&nbsp;=&nbsp;op&nbsp;(op&nbsp;x&nbsp;z)&nbsp;y.<br/>
Definition&nbsp;left_distributive&nbsp;op&nbsp;add&nbsp;:=<br/>
&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;op&nbsp;(add&nbsp;x&nbsp;y)&nbsp;z&nbsp;=&nbsp;add&nbsp;(op&nbsp;x&nbsp;z)&nbsp;(op&nbsp;y&nbsp;z).<br/>
End&nbsp;SopTisS.<br/>
<br/>
Section&nbsp;SopTisT.<br/>
Implicit&nbsp;Type&nbsp;op&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;T&nbsp;-&gt;&nbsp;T.<br/>
Definition&nbsp;left_id&nbsp;e&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;e&nbsp;x&nbsp;=&nbsp;x.<br/>
Definition&nbsp;right_zero&nbsp;z&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;x&nbsp;z&nbsp;=&nbsp;z.<br/>
Definition&nbsp;left_commutative&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;op&nbsp;x&nbsp;(op&nbsp;y&nbsp;z)&nbsp;=&nbsp;op&nbsp;y&nbsp;(op&nbsp;x&nbsp;z).<br/>
Definition&nbsp;right_distributive&nbsp;op&nbsp;add&nbsp;:=<br/>
&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;op&nbsp;x&nbsp;(add&nbsp;y&nbsp;z)&nbsp;=&nbsp;add&nbsp;(op&nbsp;x&nbsp;y)&nbsp;(op&nbsp;x&nbsp;z).<br/>
End&nbsp;SopTisT.<br/>
<br/>
Section&nbsp;SopSisT.<br/>
Implicit&nbsp;Type&nbsp;op&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;S&nbsp;-&gt;&nbsp;T.<br/>
Definition&nbsp;self_inverse&nbsp;e&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;x&nbsp;x&nbsp;=&nbsp;e.<br/>
Definition&nbsp;commutative&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x&nbsp;y,&nbsp;op&nbsp;x&nbsp;y&nbsp;=&nbsp;op&nbsp;y&nbsp;x.<br/>
End&nbsp;SopSisT.<br/>
<br/>
Section&nbsp;SopSisS.<br/>
Implicit&nbsp;Type&nbsp;op&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;S&nbsp;-&gt;&nbsp;S.<br/>
Definition&nbsp;idempotent&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x,&nbsp;op&nbsp;x&nbsp;x&nbsp;=&nbsp;x.<br/>
Definition&nbsp;associative&nbsp;op&nbsp;:=&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;op&nbsp;x&nbsp;(op&nbsp;y&nbsp;z)&nbsp;=&nbsp;op&nbsp;(op&nbsp;x&nbsp;y)&nbsp;z.<br/>
End&nbsp;SopSisS.<br/>
<br/>
End&nbsp;OperationProperties.<br/>
<br/>
<br/>
<span class="comment">(**&nbsp;**&nbsp;Boolean&nbsp;laws&nbsp;*)</span><br/>
<br/>
<span class="comment">(**&nbsp;Shorter,&nbsp;more&nbsp;systematic&nbsp;names&nbsp;for&nbsp;the&nbsp;boolean&nbsp;connectives&nbsp;laws.&nbsp;*)</span><br/>
<br/>
Lemma&nbsp;andTb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;true&nbsp;&amp;&amp;&nbsp;x&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
Lemma&nbsp;andFb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;false&nbsp;&amp;&amp;&nbsp;x&nbsp;=&nbsp;false.<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
Lemma&nbsp;andbT&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x&nbsp;&amp;&amp;&nbsp;true&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros&nbsp;<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andbF&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x&nbsp;&amp;&amp;&nbsp;false&nbsp;=&nbsp;false.<br/>
Proof.&nbsp;by&nbsp;intros&nbsp;<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andbb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x&nbsp;&amp;&amp;&nbsp;x&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros&nbsp;<span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;andbC&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;x&nbsp;&amp;&amp;&nbsp;y&nbsp;=&nbsp;y&nbsp;&amp;&amp;&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andbA&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;&amp;&amp;&nbsp;(y&nbsp;&amp;&amp;&nbsp;z)&nbsp;=&nbsp;x&nbsp;&amp;&amp;&nbsp;y&nbsp;&amp;&amp;&nbsp;z.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andbCA&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;&amp;&amp;&nbsp;(y&nbsp;&amp;&amp;&nbsp;z)&nbsp;=&nbsp;y&nbsp;&amp;&amp;&nbsp;(x&nbsp;&amp;&amp;&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andbAC&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;&amp;&amp;&nbsp;y&nbsp;&amp;&amp;&nbsp;z&nbsp;=&nbsp;x&nbsp;&amp;&amp;&nbsp;z&nbsp;&amp;&amp;&nbsp;y.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;andbN&nbsp;:&nbsp;forall&nbsp;b,&nbsp;b&nbsp;&amp;&amp;&nbsp;negb&nbsp;b&nbsp;=&nbsp;false.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andNb&nbsp;:&nbsp;forall&nbsp;b,&nbsp;negb&nbsp;b&nbsp;&amp;&amp;&nbsp;b&nbsp;=&nbsp;false.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;orTb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;true&nbsp;||&nbsp;x&nbsp;=&nbsp;true.<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
Lemma&nbsp;orFb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;false&nbsp;||&nbsp;x&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;done.&nbsp;Qed.<br/>
Lemma&nbsp;orbT&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x&nbsp;||&nbsp;true&nbsp;=&nbsp;true.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orbF&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x&nbsp;||&nbsp;false&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orbb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x&nbsp;||&nbsp;x&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;orbC&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;x&nbsp;||&nbsp;y&nbsp;=&nbsp;y&nbsp;||&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orbA&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;||&nbsp;(y&nbsp;||&nbsp;z)&nbsp;=&nbsp;x&nbsp;||&nbsp;y&nbsp;||&nbsp;z.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.&nbsp;<br/>
Lemma&nbsp;orbCA&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;||&nbsp;(y&nbsp;||&nbsp;z)&nbsp;=&nbsp;y&nbsp;||&nbsp;(x&nbsp;||&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orbAC&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;||&nbsp;y&nbsp;||&nbsp;z&nbsp;=&nbsp;x&nbsp;||&nbsp;z&nbsp;||&nbsp;y.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;orbN&nbsp;:&nbsp;forall&nbsp;b,&nbsp;b&nbsp;||&nbsp;negb&nbsp;b&nbsp;=&nbsp;true.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orNb&nbsp;:&nbsp;forall&nbsp;b,&nbsp;negb&nbsp;b&nbsp;||&nbsp;b&nbsp;=&nbsp;true.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;andb_orl&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;(x&nbsp;||&nbsp;y)&nbsp;&amp;&amp;&nbsp;z&nbsp;=&nbsp;x&nbsp;&amp;&amp;&nbsp;z&nbsp;||&nbsp;y&nbsp;&amp;&amp;&nbsp;z.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andb_orr&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;&amp;&amp;&nbsp;(y&nbsp;||&nbsp;z)&nbsp;=&nbsp;x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;x&nbsp;&amp;&amp;&nbsp;z.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orb_andl&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;(x&nbsp;&amp;&amp;&nbsp;y)&nbsp;||&nbsp;z&nbsp;=&nbsp;(x&nbsp;||&nbsp;z)&nbsp;&amp;&amp;&nbsp;(y&nbsp;||&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orb_andr&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;||&nbsp;(y&nbsp;&amp;&amp;&nbsp;z)&nbsp;=&nbsp;(x&nbsp;||&nbsp;y)&nbsp;&amp;&amp;&nbsp;(x&nbsp;||&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
<span class="comment">(**&nbsp;Pseudo-cancellation&nbsp;--&nbsp;i.e,&nbsp;absorbtion&nbsp;*)</span><br/>
<br/>
Lemma&nbsp;andbK&nbsp;:&nbsp;forall&nbsp;b1&nbsp;b2,&nbsp;b1&nbsp;&amp;&amp;&nbsp;b2&nbsp;||&nbsp;b1&nbsp;=&nbsp;b1.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;andKb&nbsp;:&nbsp;forall&nbsp;b1&nbsp;b2,&nbsp;b1&nbsp;||&nbsp;b2&nbsp;&amp;&amp;&nbsp;b1&nbsp;=&nbsp;b1.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orbK&nbsp;:&nbsp;forall&nbsp;b1&nbsp;b2,&nbsp;(b1&nbsp;||&nbsp;b2)&nbsp;&amp;&amp;&nbsp;b1&nbsp;=&nbsp;b1.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;orKb&nbsp;:&nbsp;forall&nbsp;b1&nbsp;b2,&nbsp;b1&nbsp;&amp;&amp;&nbsp;(b2&nbsp;||&nbsp;b1)&nbsp;=&nbsp;b1.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
<span class="comment">(**&nbsp;Exclusive&nbsp;or&nbsp;--&nbsp;<span class="inlinecode"><span class="id" type="var">xorb</span></span>&nbsp;*)</span><br/>
<br/>
Lemma&nbsp;xorFb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;xorb&nbsp;false&nbsp;x&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;xorbF&nbsp;:&nbsp;forall&nbsp;x,&nbsp;xorb&nbsp;x&nbsp;false&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;xorTb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;xorb&nbsp;true&nbsp;x&nbsp;=&nbsp;negb&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;xorbT&nbsp;:&nbsp;forall&nbsp;x,&nbsp;xorb&nbsp;x&nbsp;true&nbsp;=&nbsp;negb&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;xorbb&nbsp;:&nbsp;forall&nbsp;x,&nbsp;xorb&nbsp;x&nbsp;x&nbsp;=&nbsp;false.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;xorbC&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;xorb&nbsp;x&nbsp;y&nbsp;=&nbsp;xorb&nbsp;y&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;xorbA&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;xorb&nbsp;x&nbsp;(xorb&nbsp;y&nbsp;z)&nbsp;=&nbsp;xorb&nbsp;(xorb&nbsp;x&nbsp;y)&nbsp;z.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.&nbsp;<br/>
Lemma&nbsp;xorbCA&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;xorb&nbsp;x&nbsp;(xorb&nbsp;y&nbsp;z)&nbsp;=&nbsp;xorb&nbsp;y&nbsp;(xorb&nbsp;x&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.&nbsp;<br/>
Lemma&nbsp;xorbAC&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;xorb&nbsp;(xorb&nbsp;x&nbsp;y)&nbsp;z&nbsp;=&nbsp;xorb&nbsp;(xorb&nbsp;x&nbsp;z)&nbsp;y.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.&nbsp;<br/>
<br/>
Lemma&nbsp;xorbN&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;xorb&nbsp;x&nbsp;(negb&nbsp;y)&nbsp;=&nbsp;negb&nbsp;(xorb&nbsp;x&nbsp;y).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;xorNb&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;xorb&nbsp;x&nbsp;(negb&nbsp;y)&nbsp;=&nbsp;negb&nbsp;(xorb&nbsp;x&nbsp;y).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;andb_xorl&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;(xorb&nbsp;x&nbsp;y)&nbsp;&amp;&amp;&nbsp;z&nbsp;=&nbsp;xorb&nbsp;(x&nbsp;&amp;&amp;&nbsp;z)&nbsp;(y&nbsp;&amp;&amp;&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.&nbsp;<br/>
Lemma&nbsp;andb_xorr&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z,&nbsp;x&nbsp;&amp;&amp;&nbsp;(xorb&nbsp;y&nbsp;z)&nbsp;=&nbsp;xorb&nbsp;(x&nbsp;&amp;&amp;&nbsp;y)&nbsp;(x&nbsp;&amp;&amp;&nbsp;z).<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.&nbsp;<br/>
<br/>
<span class="comment">(**&nbsp;Negation&nbsp;*)</span><br/>
<br/>
Lemma&nbsp;negb_neg&nbsp;:&nbsp;forall&nbsp;x,&nbsp;negb&nbsp;(negb&nbsp;x)&nbsp;=&nbsp;x.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;negb_and&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;negb&nbsp;(x&nbsp;&amp;&amp;&nbsp;y)&nbsp;=&nbsp;negb&nbsp;x&nbsp;||&nbsp;negb&nbsp;y.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;negb_or&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;negb&nbsp;(x&nbsp;||&nbsp;y)&nbsp;=&nbsp;negb&nbsp;x&nbsp;&amp;&amp;&nbsp;negb&nbsp;y.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
Lemma&nbsp;negb_xor&nbsp;:&nbsp;forall&nbsp;x&nbsp;y,&nbsp;negb&nbsp;(xorb&nbsp;x&nbsp;y)&nbsp;=&nbsp;xorb&nbsp;(negb&nbsp;x)&nbsp;y.<br/>
Proof.&nbsp;by&nbsp;intros<span class="inlinecode"></span><span class="inlinecode"></span>.&nbsp;Qed.<br/>
<br/>
<br/>
<span class="comment">(**&nbsp;**&nbsp;Automation&nbsp;support&nbsp;*)</span><br/>
<br/>
Hint&nbsp;Rewrite&nbsp;<br/>
&nbsp;&nbsp;andTb&nbsp;andFb&nbsp;andbT&nbsp;andbF&nbsp;<br/>
&nbsp;&nbsp;orTb&nbsp;orFb&nbsp;orbT&nbsp;orbF<br/>
&nbsp;&nbsp;:&nbsp;vlib_trivial.<br/>
<br/>
Hint&nbsp;Rewrite&nbsp;<br/>
&nbsp;&nbsp;andbb&nbsp;andbN&nbsp;andNb&nbsp;<br/>
&nbsp;&nbsp;orbb&nbsp;orbN&nbsp;orNb&nbsp;<br/>
&nbsp;&nbsp;andbK&nbsp;andKb&nbsp;orbK&nbsp;orKb<br/>
&nbsp;&nbsp;xorbb&nbsp;xorFb&nbsp;xorbF&nbsp;xorTb&nbsp;xorbT&nbsp;xorbb&nbsp;negb_neg&nbsp;<br/>
&nbsp;&nbsp;:&nbsp;vlib.<br/>
<br/>
Hint&nbsp;Rewrite&nbsp;andbA&nbsp;orbA&nbsp;xorbA&nbsp;:&nbsp;vlibA.<br/>
<br/>
<span class="comment">(**&nbsp;Other&nbsp;potentially&nbsp;useful&nbsp;rewrites:&nbsp;<span class="inlinecode"><span class="id" type="var">negb_and</span></span>&nbsp;<span class="inlinecode"><span class="id" type="var">negb_or</span></span>&nbsp;<span class="inlinecode"><span class="id" type="var">negb_xor</span></span>.&nbsp;*)</span><br/>
<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;**&nbsp;Views&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<br/>
<span class="comment">(**&nbsp;An&nbsp;attempt&nbsp;to&nbsp;replicate&nbsp;functionality&nbsp;from&nbsp;ss-reflect.&nbsp;*)</span><br/>
<br/>
Section&nbsp;ApplyIff.<br/>
<br/>
Variables&nbsp;P&nbsp;Q&nbsp;:&nbsp;Prop.<br/>
Hypothesis&nbsp;eqPQ&nbsp;:&nbsp;P&nbsp;&lt;-&gt;&nbsp;Q.<br/>
<br/>
Lemma&nbsp;iffLR&nbsp;:&nbsp;P&nbsp;-&gt;&nbsp;Q.<br/>
Proof.&nbsp;tauto.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;iffRL&nbsp;:&nbsp;Q&nbsp;-&gt;&nbsp;P.<br/>
Proof.&nbsp;tauto.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;iffLRn&nbsp;:&nbsp;~P&nbsp;-&gt;&nbsp;~Q.<br/>
Proof.&nbsp;tauto.&nbsp;Qed.<br/>
<br/>
Lemma&nbsp;iffRLn&nbsp;:&nbsp;~Q&nbsp;-&gt;&nbsp;~P.<br/>
Proof.&nbsp;tauto.&nbsp;Qed.<br/>
<br/>
End&nbsp;ApplyIff.<br/>
<br/>
<br/>
<br/>
<br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;*&nbsp;Predicates,&nbsp;i.e.&nbsp;functions&nbsp;to&nbsp;bool&nbsp;(ported&nbsp;from&nbsp;ssrbool.v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;**************************************************************************&nbsp;*)</span><br/>
<br/>
<br/>
<span class="comment">(****************************************************************************)</span><br/>
<span class="comment">(*&nbsp;Predicates,&nbsp;i.e.,&nbsp;packaged&nbsp;functions&nbsp;to&nbsp;bool.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;pred&nbsp;T,&nbsp;the&nbsp;basic&nbsp;type&nbsp;for&nbsp;predicates&nbsp;over&nbsp;a&nbsp;type&nbsp;T,&nbsp;is&nbsp;simply&nbsp;an&nbsp;alias&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;for&nbsp;T&nbsp;-&gt;&nbsp;bool.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;We&nbsp;actually&nbsp;distinguish&nbsp;two&nbsp;kinds&nbsp;of&nbsp;predicates,&nbsp;which&nbsp;we&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;applicative&nbsp;and&nbsp;collective,&nbsp;based&nbsp;on&nbsp;the&nbsp;syntax&nbsp;used&nbsp;to&nbsp;specialize&nbsp;them&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;to&nbsp;some&nbsp;value&nbsp;x&nbsp;in&nbsp;T:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;-&nbsp;For&nbsp;an&nbsp;applicative&nbsp;predicate&nbsp;P,&nbsp;one&nbsp;uses&nbsp;prefix&nbsp;syntax:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;Also,&nbsp;most&nbsp;operations&nbsp;on&nbsp;applicative&nbsp;predicates&nbsp;use&nbsp;prefix&nbsp;syntax&nbsp;as&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;well&nbsp;(e.g.,&nbsp;predI&nbsp;P&nbsp;Q).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;-&nbsp;For&nbsp;a&nbsp;collective&nbsp;predicate&nbsp;A,&nbsp;one&nbsp;uses&nbsp;infix&nbsp;syntax:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;\in&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;and&nbsp;all&nbsp;operations&nbsp;on&nbsp;collective&nbsp;predicates&nbsp;use&nbsp;infix&nbsp;syntax&nbsp;as&nbsp;well&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;(e.g.,&nbsp;<span class="inlinecode"><span class="id" type="var">predI</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" type="var">B</span></span>).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;There&nbsp;are&nbsp;only&nbsp;two&nbsp;kinds&nbsp;of&nbsp;applicative&nbsp;predicates:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;-&nbsp;pred&nbsp;T,&nbsp;the&nbsp;alias&nbsp;for&nbsp;T&nbsp;-&gt;&nbsp;bool&nbsp;mentioned&nbsp;above&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;-&nbsp;simpl_pred&nbsp;T,&nbsp;an&nbsp;alias&nbsp;for&nbsp;simpl_fun&nbsp;T&nbsp;bool&nbsp;with&nbsp;a&nbsp;coercion&nbsp;to&nbsp;pred&nbsp;T&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;auto-simplifies&nbsp;on&nbsp;application&nbsp;(see&nbsp;ssrfun).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;On&nbsp;the&nbsp;other&nbsp;hand,&nbsp;the&nbsp;set&nbsp;of&nbsp;collective&nbsp;predicate&nbsp;types&nbsp;is&nbsp;open-ended,&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;via&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;-&nbsp;predType&nbsp;T,&nbsp;a&nbsp;Structure&nbsp;that&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;put&nbsp;Canonical&nbsp;collective&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;predicate&nbsp;interpretation&nbsp;on&nbsp;other&nbsp;types,&nbsp;such&nbsp;as&nbsp;lists,&nbsp;tuples,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;finite&nbsp;sets,&nbsp;etc.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Indeed,&nbsp;we&nbsp;define&nbsp;such&nbsp;interpretations&nbsp;for&nbsp;applicative&nbsp;predicate&nbsp;types,&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;which&nbsp;can&nbsp;therefore&nbsp;also&nbsp;be&nbsp;used&nbsp;with&nbsp;the&nbsp;infix&nbsp;syntax,&nbsp;e.g.&nbsp;x&nbsp;\in&nbsp;predI&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;P&nbsp;Q.&nbsp;Moreover&nbsp;these&nbsp;infix&nbsp;forms&nbsp;are&nbsp;convertible&nbsp;to&nbsp;their&nbsp;prefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;counterpart&nbsp;(e.g.,&nbsp;predI&nbsp;P&nbsp;Q&nbsp;x&nbsp;which&nbsp;in&nbsp;turn&nbsp;simplifies&nbsp;to&nbsp;P&nbsp;x&nbsp;&amp;&amp;&nbsp;Q&nbsp;x).&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;The&nbsp;converse&nbsp;is&nbsp;not&nbsp;true,&nbsp;however;&nbsp;collective&nbsp;predicate&nbsp;types&nbsp;cannot,&nbsp;in&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;general,&nbsp;be&nbsp;used&nbsp;applicatively,&nbsp;because&nbsp;of&nbsp;the&nbsp;"uniform&nbsp;inheritance"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;restriction&nbsp;on&nbsp;implicit&nbsp;coercions.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;However,&nbsp;we&nbsp;do&nbsp;define&nbsp;an&nbsp;explicit&nbsp;generic&nbsp;coercion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;-&nbsp;mem&nbsp;:&nbsp;forall&nbsp;(pT&nbsp;:&nbsp;predType),&nbsp;pT&nbsp;-&gt;&nbsp;mem_pred&nbsp;T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;mem_pred&nbsp;T&nbsp;is&nbsp;a&nbsp;variant&nbsp;of&nbsp;simpl_pred&nbsp;T&nbsp;that&nbsp;preserves&nbsp;the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;infix&nbsp;syntax,&nbsp;i.e.,&nbsp;mem&nbsp;A&nbsp;x&nbsp;auto-simplifies&nbsp;to&nbsp;x&nbsp;\in&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Indeed,&nbsp;the&nbsp;infix&nbsp;"collective"&nbsp;operators&nbsp;are&nbsp;notation&nbsp;for&nbsp;a&nbsp;prefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;operator&nbsp;with&nbsp;arguments&nbsp;of&nbsp;type&nbsp;mem_pred&nbsp;T&nbsp;or&nbsp;pred&nbsp;T,&nbsp;applied&nbsp;to&nbsp;coerced&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;collective&nbsp;predicates,&nbsp;e.g.,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notation&nbsp;"x&nbsp;\in&nbsp;A"&nbsp;:=&nbsp;(in_mem&nbsp;x&nbsp;(mem&nbsp;A)).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;This&nbsp;prevents&nbsp;the&nbsp;variability&nbsp;in&nbsp;the&nbsp;predicate&nbsp;type&nbsp;from&nbsp;interfering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;with&nbsp;the&nbsp;application&nbsp;of&nbsp;generic&nbsp;lemmas.&nbsp;Moreover&nbsp;this&nbsp;also&nbsp;makes&nbsp;it&nbsp;much&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;easier&nbsp;to&nbsp;define&nbsp;generic&nbsp;lemmas,&nbsp;because&nbsp;the&nbsp;simplest&nbsp;type&nbsp;--&nbsp;pred&nbsp;T&nbsp;--&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;can&nbsp;be&nbsp;used&nbsp;as&nbsp;the&nbsp;type&nbsp;of&nbsp;generic&nbsp;collective&nbsp;predicates,&nbsp;provided&nbsp;one&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;takes&nbsp;care&nbsp;not&nbsp;to&nbsp;use&nbsp;it&nbsp;applicatively;&nbsp;this&nbsp;avoids&nbsp;the&nbsp;burden&nbsp;of&nbsp;having&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;to&nbsp;declare&nbsp;a&nbsp;different&nbsp;predicate&nbsp;type&nbsp;for&nbsp;each&nbsp;predicate&nbsp;parameter&nbsp;of&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;each&nbsp;section&nbsp;or&nbsp;lemma.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;This&nbsp;trick&nbsp;is&nbsp;made&nbsp;possible&nbsp;by&nbsp;the&nbsp;fact&nbsp;that&nbsp;the&nbsp;constructor&nbsp;of&nbsp;the&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;mem_pred&nbsp;T&nbsp;type&nbsp;aligns&nbsp;the&nbsp;unification&nbsp;process,&nbsp;forcing&nbsp;a&nbsp;generic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;"collective"&nbsp;predicate&nbsp;A : pred&nbsp;T&nbsp;to&nbsp;unify&nbsp;with&nbsp;the&nbsp;actual&nbsp;collective&nbsp;B,&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;which&nbsp;mem&nbsp;has&nbsp;coerced&nbsp;to&nbsp;pred T&nbsp;via&nbsp;an&nbsp;internal,&nbsp;hidden&nbsp;implicit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;coercion,&nbsp;supplied&nbsp;by&nbsp;the&nbsp;predType&nbsp;structure&nbsp;for&nbsp;B.&nbsp;Users&nbsp;should&nbsp;take&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;care&nbsp;not&nbsp;to&nbsp;inadvertently&nbsp;"strip"&nbsp;(mem&nbsp;B)&nbsp;down&nbsp;to&nbsp;the&nbsp;coerced&nbsp;B,&nbsp;since&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;this&nbsp;will&nbsp;expose&nbsp;the&nbsp;internal&nbsp;coercion:&nbsp;Coq&nbsp;will&nbsp;display&nbsp;a&nbsp;term&nbsp;B&nbsp;x&nbsp;that&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;can't&nbsp;be&nbsp;typed&nbsp;as&nbsp;such.&nbsp;The&nbsp;topredE&nbsp;lemma&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;restore&nbsp;the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;x \in B&nbsp;syntax&nbsp;in&nbsp;this&nbsp;case.&nbsp;While&nbsp;-topredE&nbsp;can&nbsp;conversely&nbsp;be&nbsp;used&nbsp;to&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;change&nbsp;x \in P&nbsp;into&nbsp;P x,&nbsp;it&nbsp;is&nbsp;safer&nbsp;to&nbsp;use&nbsp;the&nbsp;inE&nbsp;and&nbsp;memE&nbsp;lemmas&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;instead,&nbsp;as&nbsp;they&nbsp;do&nbsp;not&nbsp;run&nbsp;the&nbsp;risk&nbsp;of&nbsp;exposing&nbsp;internal&nbsp;coercions.&nbsp;As&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;a&nbsp;consequence,&nbsp;it&nbsp;is&nbsp;better&nbsp;to&nbsp;explicitly&nbsp;cast&nbsp;a&nbsp;generic&nbsp;applicative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;pred T&nbsp;to&nbsp;simpl_pred,&nbsp;using&nbsp;the&nbsp;SimplPred&nbsp;constructor,&nbsp;when&nbsp;it&nbsp;is&nbsp;used&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;as&nbsp;a&nbsp;collective&nbsp;predicate&nbsp;(see,&nbsp;e.g.,&nbsp;Lemma&nbsp;eq_big&nbsp;in&nbsp;bigop.v).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;We&nbsp;also&nbsp;sometimes&nbsp;"instantiate"&nbsp;the&nbsp;predType&nbsp;structure&nbsp;by&nbsp;defining&nbsp;a&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;coercion&nbsp;to&nbsp;the&nbsp;sort&nbsp;of&nbsp;the&nbsp;predPredType&nbsp;structure.&nbsp;&nbsp;This&nbsp;works&nbsp;better&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;for&nbsp;types&nbsp;such&nbsp;as&nbsp;{set&nbsp;T}&nbsp;that&nbsp;have&nbsp;subtypes&nbsp;that&nbsp;coerce&nbsp;to&nbsp;them,&nbsp;since&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;the&nbsp;same&nbsp;coercion&nbsp;will&nbsp;be&nbsp;inserted&nbsp;by&nbsp;the&nbsp;application&nbsp;of&nbsp;mem.&nbsp;It&nbsp;also&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;allows&nbsp;us&nbsp;to&nbsp;turn&nbsp;some&nbsp;specific&nbsp;Types&nbsp;(namely,&nbsp;any&nbsp;aT : predArgType)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;into&nbsp;predicates,&nbsp;specifically,&nbsp;the&nbsp;total&nbsp;predicate&nbsp;over&nbsp;that&nbsp;type,&nbsp;i.e.,&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;fun _ :&nbsp;aT =&gt; true.&nbsp;This&nbsp;allows&nbsp;us&nbsp;to&nbsp;write,&nbsp;e.g.,&nbsp;|'I_n| for the       *)
(* cardinal of the (finite) type of integers less than n.                   *)
(*                                                                          *)
(* Collective predicates have a specific extensional equality,              *)
(* - A =i B,                                                                *)
(* while applicative predicates just use the extensional equality of        *)
(* functions,                                                               *)
(* - P =1 Q                                                                 *)
(* The two forms are convertible, however.                                  *)
(* We lift boolean operations to predicates, defining:                      *)
(* - predU (union), predI (intersection), predC (complement),               *)
(*   predD (difference), and preim (preimage, i.e., composition)            *)
(* For each operation we define three forms, typically:                     *)
(* - predU : pred T -> pred T -> simpl_pred T                               *)
(* - [predU A & B], a Notation for predU (mem A) (mem B)                    *)
(* - xpredU, a Notation for the lambda-expression inside predU,             *)
(*     which is mostly useful as an argument of =1, since it exposes the    *)
(*     head constant of the expression to the ssreflect matching algorithm. *)
(* The syntax for the preimage of a collective predicate A is               *)
(* - [preim f of A]                                                         *)
(* Finally, the generic syntax for defining a simpl_pred T is               *)
(* - [pred x : T | P(x)], [pred x | P(x)], [pred x \in A | P(x)             *)
(* We also support boolean relations, but only the applicative form, with   *)
(* types                                                                    *)
(* - rel T, an alias for T -> pred T                                        *)
(* - simpl_rel T, an auto-simplifying version, and syntax                   *)
(*   [rel x y | P(x,y)], [rel x y \in A & B | P(x,y)], etc.                 *)
(* The notation [rel of fA] can be used to coerce a function returning a    *)
(* collective predicate to one returning pred T.                            *)
(****************************************************************************)
(*

Definition pred T := T -> bool.

Identity Coercion fun_of_pred : pred >-> Funclass.

Definition rel T := T -> pred T.

Identity Coercion fun_of_rel : rel >-> Funclass.

Notation xpred0 := (fun _ => false).
Notation xpredT := (fun _ => true).
Notation xpredI := (fun (p1 p2 : pred _) x => p1 x && p2 x).
Notation xpredU := (fun (p1 p2 : pred _) x => p1 x || p2 x).
Notation xpredC := (fun (p : pred _) x => negb (p x)).
Notation xpredD := (fun (p1 p2 : pred _) x => negb (p2 x) && p1 x).
Notation xpreim := (fun f (p : pred _) x => p (f x)).
Notation xrelU := (fun (r1 r2 : rel _) x y => r1 x y || r2 x y).

Section Predicates.

Variables T : Type.

Definition subpred (p1 p2 : pred T) := forall x, p1 x -> p2 x.

Definition subrel (r1 r2 : rel T) := forall x y, r1 x y -> r2 x y.

Definition simpl_pred := simpl_fun T bool.

Definition SimplPred (p : pred T) : simpl_pred := SimplFun p.

Coercion pred_of_simpl (p : simpl_pred) : pred T := p : T -> bool.

Definition pred0 := SimplPred xpred0.
Definition predT := SimplPred xpredT.
Definition predI p1 p2 := SimplPred (xpredI p1 p2).
Definition predU p1 p2 := SimplPred (xpredU p1 p2).
Definition predC p := SimplPred (xpredC p).
Definition predD p1 p2 := SimplPred (xpredD p1 p2).
Definition preim rT f (d : pred rT) := SimplPred (xpreim f d).

Definition simpl_rel := simpl_fun T (pred T).

Definition SimplRel (r : rel T) : simpl_rel := [fun x => r x].

Coercion rel_of_simpl_rel (r : simpl_rel) : rel T := fun x y => r x y.

Definition relU r1 r2 := SimplRel (xrelU r1 r2).

Lemma subrelUl : forall r1 r2, subrel r1 (relU r1 r2).
Proof. red; ins; apply/orP; vauto. Qed.

Lemma subrelUr : forall r1 r2, subrel r2 (relU r1 r2).
Proof. red; ins; apply/orP; vauto. Qed.

Inductive mem_pred : Type := Mem (_ : pred T).

Definition isMem pT topred mem := 
  mem = (fun p : pT => Mem (fun x => topred p x)).

Structure predType : Type := PredType {
  pred_sort :> Type;
  topred : pred_sort -> pred T;
  _ : {mem | isMem topred mem}
}.

Definition mkPredType pT toP := PredType (exist (@isMem pT toP) _ eq_refl).

Canonical Structure predPredType := Eval hnf in @mkPredType (pred T) id.
Canonical Structure simplPredType := Eval hnf in mkPredType pred_of_simpl.

Coercion pred_of_mem mp : pred_sort predPredType :=
  match mp with Mem p => fun x => p x end. 

Canonical Structure memPredType := Eval hnf in mkPredType pred_of_mem.

Definition clone_pred U :=
  fun pT (_ : pred_sort pT -> U) =>
  fun a mP (pT' := @PredType U a mP) (_ : phant_id pT' pT) => pT'.

End Predicates.

Implicit Arguments topred [[T] p].
Implicit Arguments pred0 [T].
Implicit Arguments predT [T].

Notation "[ 'pred' : T | E ]" := (SimplPred (fun _ : T => E))
  (at level 0, format "[ 'pred' :  T  |  E ]") : fun_scope.
Notation "[ 'pred' x | E ]" := (SimplPred (fun x => E))
  (at level 0, x ident, format "[ 'pred'  x  |  E ]") : fun_scope.
Notation "[ 'pred' x : T | E ]" := (SimplPred (fun x : T => E))
  (at level 0, x ident, only parsing) : fun_scope.
Notation "[ 'rel' x y | E ]" := (SimplRel (fun x y => E))
  (at level 0, x ident, y ident, format "[ 'rel'  x  y  |  E ]") : fun_scope.
Notation "[ 'rel' x y : T | E ]" := (SimplRel (fun x y : T => E))
  (at level 0, x ident, y ident, only parsing) : fun_scope.

Notation "[ 'predType' 'Of' T ]" := (@clone_pred _ T _ id _ _ id)
  (at level 0, format "[ 'predType'  'Of'  T ]") : form_scope.

(* This redundant coercion lets us "inherit" the simpl_predType canonical *)
(* structure by declaring a coercion to simpl_pred. This hack is the only *)
(* way to put a predType structure on a predArgType. We use simpl_pred    *)
(* rather than pred to ensure that /= removes the identity coercion. Note *)
(* that the coercion will never be used directly for simpl_pred, since    *)
(* the canonical structure should always resolve.                         *)

Notation pred_class := (pred_sort (predPredType _)).
Coercion sort_of_simpl_pred T (p : simpl_pred T) : pred_class := p : pred T.

(* This lets us use some types as a synonym for their universal predicate. *)
(* Unfortunately, this won't work for existing types like bool, unless     *)
(* we redefine bool, true, false and all bool ops.                         *)
Definition predArgType := Type.
Identity Coercion sort_of_predArgType : predArgType >-> Sortclass.
Coercion pred_of_argType (T : predArgType) : simpl_pred T := predT.

Notation "{ : T }" := (T%type : predArgType)
  (at level 0, format "{ :  T }") : type_scope.

(* These must be defined outside a Section because "cooking" kills the *)
(* nosimpl tag.                                                        *)

Definition mem T (pT : predType T) : pT -> mem_pred T :=
  match tt with tt =>
    (match pT return pT -> _ with PredType _ _ (exist mem _) => mem end)
  end.

Definition in_mem T x mp := 
  match tt with tt => @pred_of_mem T mp x end.

Implicit Arguments mem [[T] pT].

Coercion pred_of_mem_pred T mp := [pred x : T | in_mem x mp].

Definition eq_mem T p1 p2 := forall x : T, in_mem x p1 = in_mem x p2.
Definition sub_mem T p1 p2 := forall x : T, in_mem x p1 -> in_mem x p2.

Reserved Notation "x \in A" (at level 70, no associativity).
Reserved Notation "x \notin A" (at level 70, no associativity).
Reserved Notation "p1 =i p2" (at level 70, no associativity).

Notation "x \in A" := (in_mem x (mem A)) : bool_scope.
Notation "x \in A" := (in_mem x (mem A)) : bool_scope.
Notation "x \notin A" := (negb (x \in A)) : bool_scope.
Notation "A =i B" := (eq_mem (mem A) (mem B)) : type_scope.
Notation "{ 'subset' A <= B }" := (sub_mem (mem A) (mem B))
  (at level 0, A, B at level 69,
   format "{ '[hv' 'subset'  A '/   '  <=  B ']' }") : type_scope.
Notation "[ 'mem' A ]" := (pred_of_simpl (pred_of_mem_pred (mem A)))
  (at level 0, only parsing) : fun_scope.
Notation "[ 'rel' 'Of' fA ]" := (fun x => [mem (fA x)])
  (at level 0, format "[ 'rel'  'Of'  fA ]") : fun_scope.
Notation "[ 'predI' A & B ]" := (predI [mem A] [mem B])
  (at level 0, format "[ 'predI'  A  &  B ]") : fun_scope.
Notation "[ 'predU' A & B ]" := (predU [mem A] [mem B])
  (at level 0, format "[ 'predU'  A  &  B ]") : fun_scope.
Notation "[ 'predD' A & B ]" := (predD [mem A] [mem B])
  (at level 0, format "[ 'predD'  A  &  B ]") : fun_scope.
Notation "[ 'predC' A ]" := (predC [mem A])
  (at level 0, format "[ 'predC'  A ]") : fun_scope.
Notation "[ 'preim' f 'Of' A ]" := (preim f [mem A])
  (at level 0, format "[ 'preim'  f  'Of'  A ]") : fun_scope.

Notation "[ 'pred' x \in A ]" := [pred x | x \in A]
  (at level 0, x ident, format "[ 'pred'  x  \in  A ]") : fun_scope.
Notation "[ 'pred' x \in A | E ]" := [pred x | (x \in A) && E]
  (at level 0, x ident, format "[ 'pred'  x  \in  A  |  E ]") : fun_scope.
Notation "[ 'rel' x y \in A & B | E ]" :=
  [rel x y | (x \in A) && (y \in B) && E]
  (at level 0, x ident, y ident,
   format "[ 'rel'  x  y  \in  A  &  B  |  E ]") : fun_scope.
Notation "[ 'rel' x y \in A & B ]" := [rel x y | (x \in A) && (y \in B)]
  (at level 0, x ident, y ident,
   format "[ 'rel'  x  y  \in  A  &  B ]") : fun_scope.
Notation "[ 'rel' x y \in A | E ]" := [rel x y \in A & A | E]
  (at level 0, x ident, y ident,
   format "[ 'rel'  x  y  \in  A  |  E ]") : fun_scope.
Notation "[ 'rel' x y \in A ]" := [rel x y \in A & A]
  (at level 0, x ident, y ident,
   format "[ 'rel'  x  y  \in  A ]") : fun_scope.

Section simpl_mem.

Variables (T : Type) (pT : predType T).

Lemma mem_topred : forall (p : pT), mem (topred p) = mem p.
Proof. by unfold mem; case pT; intros T1 app1 [mem1 ->]. Qed.

Lemma topredE : forall x (p : pT), topred p x = (x \in p).
Proof. by intros; rewrite <-mem_topred. Qed.

Lemma in_simpl : forall x (p : simpl_pred T), (x \in p) = p x.
Proof. done. Qed.

Lemma simpl_predE : forall (p : pred T), [pred x | p x] =1 p.
Proof. done. Qed.

(* Definition inE := (in_simpl, simpl_predE). (* to be extended *) *)

Lemma mem_simpl : forall (p : simpl_pred T), mem p = p :> pred T.
Proof. done. Qed.

Definition memE := mem_simpl. (* could be extended *)

(*
Lemma mem_mem : forall p : pT, (mem (mem p) = mem p) /\ (mem [mem p] = mem p).
Proof. by intros p; rewrite <-mem_topred. Qed.
*)

End simpl_mem.

Section RelationProperties.

(* Caveat: reflexive should not be used to state lemmas, since auto *)
(* and trivial will not expand the constant.                        *)

Variable T : Type.

Variable R : rel T.

Definition total := forall x y, R x y || R y x.
Definition transitive := forall x y z, R x y -> R y z -> R x z.

Definition symmetric := forall x y, R x y = R y x.
Definition antisymmetric := forall x y, R x y -> R y x -> x = y.
Definition pre_symmetric := forall x y, R x y -> R y x.

Lemma symmetric_from_pre : pre_symmetric -> symmetric.
Proof. split/; apply H. Qed.

Lemma pre_from_symmetric : symmetric -> pre_symmetric.
Proof. by red; ins; rewrite H. Qed.

Definition reflexive := forall x, R x x.
Definition irreflexive := forall x, R x x = false.

Definition left_transitive := forall x y, R x y -> R x =1 R y.
Definition right_transitive := forall x y, R x y -> R^~ x =1 R^~ y.

End RelationProperties.

Lemma rev_trans : forall T (R : rel T),
  transitive R -> transitive (fun x y => R y x).
Proof. eby red; intros; eapply H. Qed.

(* Property localization *)

Notation Local "{ 'all1' P }" := (forall x, P x : Prop) (at level 0).
Notation Local "{ 'all2' P }" := (forall x y, P x y : Prop) (at level 0).
Notation Local "{ 'all3' P }" := (forall x y z, P x y z: Prop) (at level 0).
Notation Local ph := (phantom _).

Section LocalProperties.

Variables T1 T2 T3 : Type.

Variables (d1 : mem_pred T1) (d2 : mem_pred T2) (d3 : mem_pred T3).
Notation Local ph := (phantom Prop).

Definition prop_for (x : T1) P (_ : ph {all1 P}) := P x.

Lemma forE : forall x P phP, @prop_for x P phP = P x.
Proof. done. Qed. 

Definition prop_in1 P (_ : ph {all1 P}) :=
  forall x, in_mem x d1 -> P x.

Definition prop_in11 P (_ : ph {all2 P}) :=
  forall x y, in_mem x d1 -> in_mem y d2 -> P x y.

Definition prop_in2 P (_ : ph {all2 P}) :=
  forall x y, in_mem x d1 -> in_mem y d1 -> P x y.

Definition prop_in111 P (_ : ph {all3 P}) :=
  forall x y z, in_mem x d1 -> in_mem y d2 -> in_mem z d3 -> P x y z.

Definition prop_in12 P (_ : ph {all3 P}) :=
  forall x y z, in_mem x d1 -> in_mem y d2 -> in_mem z d2 -> P x y z.

Definition prop_in21 P (_ : ph {all3 P}) :=
  forall x y z, in_mem x d1 -> in_mem y d1 -> in_mem z d2 -> P x y z.

Definition prop_in3 P (_ : ph {all3 P}) :=
  forall x y z, in_mem x d1 -> in_mem y d1 -> in_mem z d1 -> P x y z.

Variable f : T1 -> T2.

Definition prop_on1 Pf P (_ : phantom T3 (Pf f)) (_ : ph {all1 P}) :=
  forall x, in_mem (f x) d2 -> P x.

Definition prop_on2 Pf P (_ : phantom T3 (Pf f)) (_ : ph {all2 P}) :=
  forall x y, in_mem (f x) d2 -> in_mem (f y) d2 -> P x y.

End LocalProperties.

Implicit Arguments prop_in1 [T1 P].
Implicit Arguments prop_in11 [T1 T2 P].
Implicit Arguments prop_in2 [T1 P].
Implicit Arguments prop_in111 [T1 T2 T3 P].
Implicit Arguments prop_in12 [T1 T2 P].
Implicit Arguments prop_in21 [T1 T2 P].
Implicit Arguments prop_in3 [T1 P].
Implicit Arguments prop_on1 [T1 T2 T3 f Pf P].
Implicit Arguments prop_on2 [T1 T2 T3 f Pf P].

Definition inPhantom := Phantom Prop.
Definition onPhantom T P (x : T) := Phantom Prop (P x).

Definition bijective_in aT rT (d : mem_pred aT) (f : aT -> rT) :=
  exists2 g, prop_in1 d (inPhantom (cancel f g))
           & prop_on1 d (Phantom _ (cancel g)) (onPhantom (cancel g) f).

Definition bijective_on aT rT (cd : mem_pred rT) (f : aT -> rT) :=
  exists2 g, prop_on1 cd (Phantom _ (cancel f)) (onPhantom (cancel f) g)
           & prop_in1 cd (inPhantom (cancel g f)).

Notation "{ 'for' x , P }" :=
  (prop_for x (inPhantom P))
  (at level 0, format "{ 'for'  x ,  P }") : type_scope.

Notation "{ 'in' d , P }" :=
  (prop_in1 (mem d) (inPhantom P))
  (at level 0, format "{ 'in'  d ,  P }") : type_scope.

Notation "{ 'in' d1 & d2 , P }" :=
  (prop_in11 (mem d1) (mem d2) (inPhantom P))
  (at level 0, format "{ 'in'  d1  &  d2 ,  P }") : type_scope.

Notation "{ 'in' d & , P }" :=
  (prop_in2 (mem d) (inPhantom P))
  (at level 0, format "{ 'in'  d  & ,  P }") : type_scope.

Notation "{ 'in' d1 & d2 & d3 , P }" :=
  (prop_in111 (mem d1) (mem d2) (mem d3) (inPhantom P))
  (at level 0, format "{ 'in'  d1  &  d2  &  d3 ,  P }") : type_scope.

Notation "{ 'in' d1 & & d3 , P }" :=
  (prop_in21 (mem d1) (mem d3) (inPhantom P))
  (at level 0, format "{ 'in'  d1  &  &  d3 ,  P }") : type_scope.

Notation "{ 'in' d1 & d2 & , P }" :=
  (prop_in12 (mem d1) (mem d2) (inPhantom P))
  (at level 0, format "{ 'in'  d1  &  d2  & ,  P }") : type_scope.

Notation "{ 'in' d & & , P }" :=
  (prop_in3 (mem d) (inPhantom P))
  (at level 0, format "{ 'in'  d  &  & ,  P }") : type_scope.

Notation "{ 'on' cd , P }" :=
  (prop_on1 (mem cd) (inPhantom P) (inPhantom P))
  (at level 0, format "{ 'on'  cd ,  P }") : type_scope.

Notation "{ 'on' cd & , P }" :=
  (prop_on2 (mem cd) (inPhantom P) (inPhantom P))
  (at level 0, format "{ 'on'  cd  & ,  P }") : type_scope.

Notation "{ 'on' cd , P & g }" :=
  (prop_on1 (mem cd) (Phantom (_ -> Prop) P) (onPhantom P g))
  (at level 0, format "{ 'on'  cd ,  P  &  g }") : type_scope.

Notation "{ 'in' d , 'bijective' f }" := (bijective_in (mem d) f)
  (at level 0, f at level 8,
   format "{ 'in'  d ,  'bijective'  f }") : type_scope.

Notation "{ 'on' cd , 'bijective' f }" := (bijective_on (mem cd) f)
  (at level 0, f at level 8,
   format "{ 'on'  cd ,  'bijective'  f }") : type_scope.

(* Weakening and monotonicity lemmas for localized predicates. *)
(* Note that using these lemmas in backward reasoning will     *)
(* cause the expansion of the predicate definition, as Coq     *)
(* needs to expose the quantifier to apply these lemmas. We    *)
(* define some specialized variants to avoid this for some of  *)
(* the ssrfun definitions.                                     *)

Section LocalGlobal.

Variables T1 T2 T3 : predArgType.
Variables (D1 : pred T1) (D2 : pred T2) (D3 : pred T3).
Variables (d1 d1' : mem_pred T1) (d2 d2' : mem_pred T2) (d3 d3' : mem_pred T3).
Variables (f f' : T1 -> T2) (g : T2 -> T1) (h : T3).
Variables (P1 : T1 -> Prop) (P2 : T1 -> T2 -> Prop).
Variable P3 : T1 -> T2 -> T3 -> Prop.
Variable Q1 : (T1 -> T2) -> T1 -> Prop.
Variable Q1l : (T1 -> T2) -> T3 -> T1 -> Prop.
Variable Q2 : (T1 -> T2) -> T1 -> T1 -> Prop.

Hypothesis sub1 : sub_mem d1 d1'.
Hypothesis sub2 : sub_mem d2 d2'.
Hypothesis sub3 : sub_mem d3 d3'.

Lemma in1W : {all1 P1} -> {in D1, {all1 P1}}.
Proof. by red. Qed.
Lemma in2W : {all2 P2} -> {in D1 & D2, {all2 P2}}.
Proof. by red. Qed.
Lemma in3W : {all3 P3} -> {in D1 & D2 & D3, {all3 P3}}.
Proof. by red. Qed.

Lemma in1T : {in T1, {all1 P1}} -> {all1 P1}.
Proof. auto. Qed.
Lemma in2T : {in T1 & T2, {all2 P2}} -> {all2 P2}.
Proof. auto. Qed.
Lemma in3T : {in T1 & T2 & T3, {all3 P3}} -> {all3 P3}.
Proof. auto. Qed.

Lemma sub_in1 : forall Ph : ph {all1 P1},
  prop_in1 d1' Ph -> prop_in1 d1 Ph.
Proof. by intros ? allP x; move/sub1; apply allP. Qed.

Lemma sub_in11 : forall Ph : ph {all2 P2},
  prop_in11 d1' d2' Ph -> prop_in11 d1 d2 Ph.
Proof. by intros ? allP x1 x2; move/sub1; intro d1x1; move/sub2; apply allP. Qed.

Lemma sub_in111 :  forall Ph : ph {all3 P3},
  prop_in111 d1' d2' d3' Ph -> prop_in111 d1 d2 d3 Ph.
Proof.
intros ? allP x1 x2 x3.
by move/sub1; intro; move/sub2; intro; move/sub3; apply allP.
Qed.

Let allQ1 f'' := {all1 Q1 f''}.
Let allQ1l f'' h' := {all1 Q1l f'' h'}.
Let allQ2 f'' := {all2 Q2 f''}.

Lemma on1W : allQ1 f -> {on D2, allQ1 f}.
Proof. by red. Qed.
Lemma on1lW : allQ1l f h -> {on D2, allQ1l f & h}.
Proof. by red. Qed.
Lemma on2W : allQ2 f -> {on D2 &, allQ2 f}.
Proof. by red. Qed.

Lemma on1T : {on T2, allQ1 f} -> allQ1 f.
Proof. red; auto. Qed.
Lemma on1lT : {on T2, allQ1l f & h} -> allQ1l f h.
Proof. red; auto. Qed.
Lemma on2T : {on T2 &, allQ2 f} -> allQ2 f.
Proof. red; auto. Qed.

Lemma subon1 : forall (Phf : ph (allQ1 f)) (Ph : ph (allQ1 f)),
  prop_on1 d2' Phf Ph -> prop_on1 d2 Phf Ph.
Proof. by intros ? ? allQ x; move/sub2; apply allQ. Qed.

Lemma subon1l : forall (Phf : ph (allQ1l f)) (Ph : ph (allQ1l f h)),
  prop_on1 d2' Phf Ph -> prop_on1 d2 Phf Ph.
Proof. by intros ? ? allQ x; move/sub2; apply allQ. Qed.

Lemma subon2 : forall (Phf : ph (allQ2 f)) (Ph : ph (allQ2 f)),
  prop_on2 d2' Phf Ph -> prop_on2 d2 Phf Ph.
Proof. by intros ? ? allQ x y; move/sub2; intro; move/sub2; apply allQ. Qed.

Lemma can_in_inj : {in D1, cancel f g} -> {in D1 &, injective f}.
Proof. intros fK x y; do 2 (move/fK; intro); congruence. Qed.

Lemma canLR_in : forall x y,
  {in D1, cancel f g} -> y \in D1 -> x = f y -> g x = y.
Proof. by intros x y fK D1y ->; rewrite fK. Qed.

Lemma canRL_in : forall x y,
  {in D1, cancel f g} -> x \in D1 -> f x = y -> x = g y.
Proof. by intros x y fK D1x <-; rewrite fK. Qed.

Lemma on_can_inj : {on D2, cancel f & g} -> {on D2 &, injective f}.
Proof. intros fK x y; do 2 (move/fK; intro); congruence. Qed.

Lemma canLR_on : forall x y,
  {on D2, cancel f & g} -> f y \in D2 -> x = f y -> g x = y.
Proof. by intros x y fK D2fy ->; rewrite fK. Qed.

Lemma canRL_on : forall x y,
  {on D2, cancel f & g} -> f x \in D2 -> f x = y -> x = g y.
Proof. by intros x y fK D2fx <-; rewrite fK. Qed.

Lemma inW_bij : bijective f -> {in D1, bijective f}.
Proof. by destruct 1 as [g']; exists g'; red; auto. Qed.

Lemma onW_bij : bijective f -> {on D2, bijective f}.
Proof. by destruct 1 as [g']; exists g'; red; auto. Qed.

Lemma inT_bij : {in T1, bijective f} -> bijective f.
Proof. destruct 1 as [g']; exists g'; red; auto. Qed.

Lemma onT_bij : {on T2, bijective f} -> bijective f.
Proof. destruct 1 as [g']; exists g'; red; auto. Qed.

Lemma sub_in_bij : forall D1' : pred T1,
  {subset D1 <= D1'} -> {in D1', bijective f} -> {in D1, bijective f}.
Proof. destruct 2 as [g']; eexists g'; red; auto. Qed. 

Lemma subon_bij :  forall D2' : pred T2,
 {subset D2 <= D2'} -> {on D2', bijective f} -> {on D2, bijective f}.
Proof. destruct 2 as [g']; eexists g'; red; auto. Qed. 

End LocalGlobal.

Lemma sub_in2 : forall T d d' (P : T -> T -> Prop),
  sub_mem d d' -> forall Ph : ph {all2 P}, prop_in2 d' Ph -> prop_in2 d Ph.
Proof. by intros until 1; apply sub_in11. Qed.

Lemma sub_in3 : forall T d d' (P : T -> T -> T -> Prop),
  sub_mem d d' -> forall Ph : ph {all3 P}, prop_in3 d' Ph -> prop_in3 d Ph.
Proof. by intros until 1; apply sub_in111. Qed.

Lemma sub_in12 : forall T1 T d1 d1' d d' (P : T1 -> T -> T -> Prop),
  sub_mem d1 d1' -> sub_mem d d' ->
  forall Ph : ph {all3 P}, prop_in12 d1' d' Ph -> prop_in12 d1 d Ph.
Proof. by intros until 2; apply sub_in111. Qed.

Lemma sub_in21 : forall T T3 d d' d3 d3' (P : T -> T -> T3 -> Prop),
  sub_mem d d' -> sub_mem d3 d3' ->
  forall Ph : ph {all3 P}, prop_in21 d' d3' Ph -> prop_in21 d d3 Ph.
Proof. by intros until 2; apply sub_in111. Qed.

*)

(** Comparison for [nat] *)

Fixpoint eqn_rec (x y: nat) {struct x} :=
   match x, y with
     | O, O => true
     | S x, S y => eqn_rec x y
     | _, _ => false
   end.

Definition eqn := match tt with tt => eqn_rec end.

Lemma eqnP: forall x y, reflect (x = y) (eqn x y).
Proof.
  induction[] x [y]; vauto. 
  change (eqn (S x) (S y)) with (eqn x y).
  case IHx; constructor; congruence.
Qed.

Canonical Structure nat_eqMixin := EqMixin eqnP.
Canonical Structure nat_eqType := Eval hnf in EqType nat nat_eqMixin.

Lemma eqnE : eqn = (@eq_op _).
Proof. done. Qed.
*)</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>