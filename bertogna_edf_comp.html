<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>bertogna_edf_comp</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library bertogna_edf_comp</h1>

<div class="code">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="Vbase.html#"><span class="id" type="library">Vbase</span></a> <a class="idref" href="task.html#"><span class="id" type="library">task</span></a> <a class="idref" href="job.html#"><span class="id" type="library">job</span></a> <a class="idref" href="task_arrival.html#"><span class="id" type="library">task_arrival</span></a> <a class="idref" href="schedule.html#"><span class="id" type="library">schedule</span></a> <a class="idref" href="platform.html#"><span class="id" type="library">platform</span></a> <a class="idref" href="interference.html#"><span class="id" type="library">interference</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="workload.html#"><span class="id" type="library">workload</span></a> <a class="idref" href="workload_bound.html#"><span class="id" type="library">workload_bound</span></a> <a class="idref" href="schedulability.html#"><span class="id" type="library">schedulability</span></a> <a class="idref" href="priority.html#"><span class="id" type="library">priority</span></a> <a class="idref" href="response_time.html#"><span class="id" type="library">response_time</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_fp_theory.html#"><span class="id" type="library">bertogna_fp_theory</span></a> <a class="idref" href="bertogna_edf_theory.html#"><span class="id" type="library">bertogna_edf_theory</span></a> <a class="idref" href="interference_bound_edf.html#"><span class="id" type="library">interference_bound_edf</span></a> <a class="idref" href="util_divround.html#"><span class="id" type="library">util_divround</span></a> <a class="idref" href="util_lemmas.html#"><span class="id" type="library">util_lemmas</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="library">ssreflect</span> <span class="id" type="library">ssrbool</span> <span class="id" type="library">eqtype</span> <span class="id" type="library">ssrnat</span> <span class="id" type="library">seq</span> <span class="id" type="library">fintype</span> <span class="id" type="library">bigop</span> <span class="id" type="library">div</span> <span class="id" type="library">path</span>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <a name="ResponseTimeIterationEDF"><span class="id" type="module">ResponseTimeIterationEDF</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Import</span> <span class="id" type="var">Job</span> <span class="id" type="var">SporadicTaskset</span> <span class="id" type="var">ScheduleOfSporadicTask</span> <span class="id" type="var">Workload</span> <span class="id" type="var">Schedulability</span> <span class="id" type="var">ResponseTime</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Priority</span> <span class="id" type="var">SporadicTaskArrival</span> <span class="id" type="var">WorkloadBound</span> <span class="id" type="var">EDFSpecificBound</span> <span class="id" type="var">ResponseTimeAnalysisFP</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ResponseTimeAnalysisEDF</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;this&nbsp;section,&nbsp;we&nbsp;define&nbsp;the&nbsp;algorithm&nbsp;of&nbsp;Bertogna&nbsp;and&nbsp;Cirinei's<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response-time&nbsp;analysis&nbsp;for&nbsp;EDF&nbsp;scheduling.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis"><span class="id" type="section">Analysis</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Context</span> {<span class="id" type="var">sporadic_task</span>: <span class="id" type="abbreviation">eqType</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;During&nbsp;the&nbsp;iterations&nbsp;of&nbsp;the&nbsp;algorithm,&nbsp;we&nbsp;pass&nbsp;around&nbsp;pairs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;tasks&nbsp;and&nbsp;computed&nbsp;response-time&nbsp;bounds.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a> := (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>)%<span class="id" type="var">type</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Context</span> {<span class="id" type="var">Job</span>: <span class="id" type="abbreviation">eqType</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Job"><span class="id" type="variable">Job</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.job_deadline"><span class="id" type="variable">job_deadline</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Job"><span class="id" type="variable">Job</span></a> -&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Job"><span class="id" type="variable">Job</span></a> -&gt; <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Consider&nbsp;a&nbsp;platform&nbsp;with&nbsp;num_cpus&nbsp;processors.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.num_cpus"><span class="id" type="variable">num_cpus</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;First,&nbsp;recall&nbsp;the&nbsp;interference&nbsp;bound&nbsp;under&nbsp;EDF,&nbsp;...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.I"><span class="id" type="variable">I</span></a> (<span class="id" type="var">rt_bounds</span>: <span class="id" type="abbreviation">seq</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">tsk</span>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) (<span class="id" type="keyword">delta</span>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.time"><span class="id" type="definition">time</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_theory.html#ResponseTimeAnalysisEDF.total_interference_bound_edf"><span class="id" type="definition">total_interference_bound_edf</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> <span class="id" type="keyword">delta</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...,&nbsp;which&nbsp;yields&nbsp;the&nbsp;following&nbsp;response-time&nbsp;bound.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.edf_response_time_bound"><span class="id" type="definition">edf_response_time_bound</span></a> (<span class="id" type="var">rt_bounds</span>: <span class="id" type="abbreviation">seq</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">tsk</span>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) (<span class="id" type="keyword">delta</span>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.time"><span class="id" type="definition">time</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="notation">+</span> <a class="idref" href="util_divround.html#div_floor"><span class="id" type="definition">div_floor</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.I"><span class="id" type="variable">I</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="keyword">delta</span>) <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.num_cpus"><span class="id" type="variable">num_cpus</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Also&nbsp;note&nbsp;that&nbsp;a&nbsp;response-time&nbsp;is&nbsp;only&nbsp;valid&nbsp;if&nbsp;it&nbsp;is&nbsp;no&nbsp;larger<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;than&nbsp;the&nbsp;deadline.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.R_le_deadline"><span class="id" type="definition">R_le_deadline</span></a> (<span class="id" type="var">pair</span>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">tsk</span>, <span class="id" type="var">R</span>) := <a class="idref" href="bertogna_edf_comp.html#pair"><span class="id" type="variable">pair</span></a> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Next&nbsp;we&nbsp;define&nbsp;the&nbsp;fixed-point&nbsp;iteration&nbsp;for&nbsp;computing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bertogna's&nbsp;response-time&nbsp;bound&nbsp;of&nbsp;a&nbsp;task&nbsp;set.&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Given&nbsp;a&nbsp;sequence&nbsp;'rt_bounds'&nbsp;of&nbsp;task&nbsp;and&nbsp;response-time&nbsp;bounds<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;the&nbsp;previous&nbsp;iteration,&nbsp;we&nbsp;compute&nbsp;the&nbsp;response-time<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bound&nbsp;of&nbsp;a&nbsp;single&nbsp;task&nbsp;using&nbsp;the&nbsp;RTA&nbsp;for&nbsp;EDF.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.update_bound"><span class="id" type="definition">update_bound</span></a> (<span class="id" type="var">rt_bounds</span>: <span class="id" type="abbreviation">seq</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">pair</span> : <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">tsk</span>, <span class="id" type="var">R</span>) := <a class="idref" href="bertogna_edf_comp.html#pair"><span class="id" type="variable">pair</span></a> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_response_time_bound"><span class="id" type="definition">edf_response_time_bound</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;To&nbsp;compute&nbsp;the&nbsp;response-time&nbsp;bounds&nbsp;of&nbsp;the&nbsp;entire&nbsp;task&nbsp;set,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;start&nbsp;the&nbsp;iteration&nbsp;with&nbsp;a&nbsp;sequence&nbsp;of&nbsp;tasks&nbsp;and&nbsp;costs:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;(task1,&nbsp;cost1),&nbsp;(task2,&nbsp;cost2),&nbsp;...&gt;.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> (<span class="id" type="var">ts</span>: <a class="idref" href="task.html#SporadicTaskset.taskset_of"><span class="id" type="definition">taskset_of</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">t</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#t"><span class="id" type="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#t"><span class="id" type="variable">t</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>) <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Then,&nbsp;we&nbsp;successively&nbsp;update&nbsp;the&nbsp;the&nbsp;response-time&nbsp;bounds&nbsp;based<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;the&nbsp;slack&nbsp;computed&nbsp;in&nbsp;the&nbsp;previous&nbsp;iteration.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> (<span class="id" type="var">rt_bounds</span>: <span class="id" type="abbreviation">seq</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">map</span> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.update_bound"><span class="id" type="definition">update_bound</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a>) <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;To&nbsp;ensure&nbsp;that&nbsp;the&nbsp;procedure&nbsp;converges,&nbsp;we&nbsp;run&nbsp;the&nbsp;iteration&nbsp;a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"sufficient"&nbsp;number&nbsp;of&nbsp;times:&nbsp;task_deadline&nbsp;tsk&nbsp;-&nbsp;task_cost&nbsp;tsk&nbsp;+&nbsp;1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;time&nbsp;complexity&nbsp;of&nbsp;the&nbsp;procedure.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> (<span class="id" type="var">ts</span>: <a class="idref" href="task.html#SporadicTaskset.taskset_of"><span class="id" type="definition">taskset_of</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="notation">\</span><span class="id" type="notation">sum_</span><span class="id" type="notation">(</span><span class="id" type="var">tsk</span> <span class="id" type="notation">&lt;-</span> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a><span class="id" type="notation">)</span> <span class="id" type="notation">(</span><a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <span class="id" type="var">tsk</span> <span class="id" type="notation">-</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <span class="id" type="var">tsk</span><span class="id" type="notation">)</span> <span class="id" type="notation">+</span> 1.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;yields&nbsp;the&nbsp;following&nbsp;definition&nbsp;for&nbsp;the&nbsp;RTA.&nbsp;At&nbsp;the&nbsp;end&nbsp;of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;iteration,&nbsp;we&nbsp;check&nbsp;if&nbsp;all&nbsp;computed&nbsp;response-time&nbsp;bounds<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the&nbsp;deadline,&nbsp;in&nbsp;which&nbsp;case&nbsp;they&nbsp;are<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valid.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> (<span class="id" type="var">ts</span>: <a class="idref" href="task.html#SporadicTaskset.taskset_of"><span class="id" type="definition">taskset_of</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">R_values</span> := <span class="id" type="definition">iter</span> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a>) <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="notation">(</span><span class="id" type="definition">all</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.R_le_deadline"><span class="id" type="definition">R_le_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#R_values"><span class="id" type="variable">R_values</span></a><span class="id" type="notation">)</span> <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <a class="idref" href="bertogna_edf_comp.html#R_values"><span class="id" type="variable">R_values</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;schedulability&nbsp;test&nbsp;simply&nbsp;checks&nbsp;if&nbsp;we&nbsp;got&nbsp;a&nbsp;list&nbsp;of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response-time&nbsp;bounds&nbsp;(i.e.,&nbsp;if&nbsp;the&nbsp;computation&nbsp;did&nbsp;not&nbsp;fail).&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.edf_schedulable"><span class="id" type="definition">edf_schedulable</span></a> (<span class="id" type="var">ts</span>: <a class="idref" href="task.html#SporadicTaskset.taskset_of"><span class="id" type="definition">taskset_of</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a> <span class="id" type="notation">!=</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;the&nbsp;following&nbsp;section,&nbsp;we&nbsp;prove&nbsp;several&nbsp;helper&nbsp;lemmas&nbsp;about&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;of&nbsp;tasks/response-time&nbsp;bounds.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis.SimpleLemmas"><span class="id" type="section">SimpleLemmas</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Updating&nbsp;a&nbsp;single&nbsp;response-time&nbsp;bound&nbsp;does&nbsp;not&nbsp;modify&nbsp;the&nbsp;task.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_unzip1_update_bound"><span class="id" type="lemma">edf_claimed_bounds_unzip1_update_bound</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l</span> <span class="id" type="var">rt_bounds</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">unzip1</span> (<span class="id" type="definition">map</span> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.update_bound"><span class="id" type="definition">update_bound</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a>) <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="definition">unzip1</span> <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;any&nbsp;point&nbsp;of&nbsp;the&nbsp;iteration,&nbsp;the&nbsp;tasks&nbsp;are&nbsp;the&nbsp;same.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_unzip1_iteration"><span class="id" type="lemma">edf_claimed_bounds_unzip1_iteration</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">unzip1</span> (<span class="id" type="definition">iter</span> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>)) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;iteration&nbsp;preserves&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;list.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_size"><span class="id" type="lemma">edf_claimed_bounds_size</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">size</span> (<span class="id" type="definition">iter</span> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>)) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="definition">size</span> <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;If&nbsp;the&nbsp;analysis&nbsp;succeeds,&nbsp;the&nbsp;computed&nbsp;response-time&nbsp;bounds&nbsp;are&nbsp;no&nbsp;smaller<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;than&nbsp;the&nbsp;task&nbsp;cost.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_ge_cost"><span class="id" type="lemma">edf_claimed_bounds_ge_cost</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l</span> <span class="id" type="var">k</span> <span class="id" type="var">tsk</span> <span class="id" type="var">R</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <span class="id" type="notation">(</span><span class="id" type="definition">iter</span> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#l"><span class="id" type="variable">l</span></a>)<span class="id" type="notation">)</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a> <span class="id" type="notation">&gt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;If&nbsp;the&nbsp;analysis&nbsp;suceeds,&nbsp;the&nbsp;computed&nbsp;response-time&nbsp;bounds&nbsp;are&nbsp;no&nbsp;larger<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;than&nbsp;the&nbsp;deadline.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_le_deadline"><span class="id" type="lemma">edf_claimed_bounds_le_deadline</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">ts</span> <span class="id" type="var">rt_bounds</span> <span class="id" type="var">tsk</span> <span class="id" type="var">R</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;list&nbsp;contains&nbsp;a&nbsp;response-time&nbsp;bound&nbsp;for&nbsp;every&nbsp;task&nbsp;in&nbsp;the&nbsp;task&nbsp;set.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_has_R_for_every_task"><span class="id" type="lemma">edf_claimed_bounds_has_R_for_every_task</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">ts</span> <span class="id" type="var">rt_bounds</span> <span class="id" type="var">tsk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#ts"><span class="id" type="variable">ts</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">exists</span></a> <span class="id" type="var">R</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.SimpleLemmas"><span class="id" type="section">SimpleLemmas</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;As&nbsp;required&nbsp;by&nbsp;the&nbsp;proof&nbsp;of&nbsp;convergence,&nbsp;we&nbsp;show&nbsp;that&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interference&nbsp;bound&nbsp;is&nbsp;monotonically&nbsp;increasing&nbsp;with&nbsp;both<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;interval&nbsp;and&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;previous<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response-time&nbsp;bounds.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TODO:&nbsp;move&nbsp;to&nbsp;bertogna_edf_theory.v?&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound"><span class="id" type="section">MonotonicityOfInterferenceBound</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk"><span class="id" type="variable">tsk</span></a> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk_other"><span class="id" type="variable">tsk_other</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.H_period_positive"><span class="id" type="variable">H_period_positive</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk_other"><span class="id" type="variable">tsk_other</span></a> <span class="id" type="notation">&gt;</span> 0.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <span class="id" type="keyword">delta</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.delta'"><span class="id" type="variable">delta'</span></a> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R"><span class="id" type="variable">R</span></a> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R'"><span class="id" type="variable">R'</span></a>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.time"><span class="id" type="definition">time</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.H_delta_monotonic"><span class="id" type="variable">H_delta_monotonic</span></a>: <span class="id" type="keyword">delta</span> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.delta'"><span class="id" type="variable">delta'</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.H_response_time_monotonic"><span class="id" type="variable">H_response_time_monotonic</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R"><span class="id" type="variable">R</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R'"><span class="id" type="variable">R'</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.H_cost_le_rt_bound"><span class="id" type="variable">H_cost_le_rt_bound</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk_other"><span class="id" type="variable">tsk_other</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R"><span class="id" type="variable">R</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.interference_bound_edf_monotonic"><span class="id" type="lemma">interference_bound_edf_monotonic</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_theory.html#ResponseTimeAnalysisEDF.interference_bound_edf"><span class="id" type="definition">interference_bound_edf</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="keyword">delta</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk_other"><span class="id" type="variable">tsk_other</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="notation">&lt;=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_theory.html#ResponseTimeAnalysisEDF.interference_bound_edf"><span class="id" type="definition">interference_bound_edf</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk"><span class="id" type="variable">tsk</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.delta'"><span class="id" type="variable">delta'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.tsk_other"><span class="id" type="variable">tsk_other</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound.R'"><span class="id" type="variable">R'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MonotonicityOfInterferenceBound"><span class="id" type="section">MonotonicityOfInterferenceBound</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;this&nbsp;section,&nbsp;we&nbsp;prove&nbsp;the&nbsp;convergence&nbsp;of&nbsp;the&nbsp;RTA&nbsp;procedure.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since&nbsp;we&nbsp;define&nbsp;the&nbsp;RTA&nbsp;procedure&nbsp;as&nbsp;the&nbsp;application&nbsp;of&nbsp;a&nbsp;function<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;fixed&nbsp;number&nbsp;of&nbsp;times,&nbsp;this&nbsp;translates&nbsp;into&nbsp;proving&nbsp;that&nbsp;the&nbsp;value<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;iteration&nbsp;at&nbsp;(max_steps&nbsp;ts)&nbsp;is&nbsp;equal&nbsp;to&nbsp;the&nbsp;value&nbsp;at&nbsp;(max_steps&nbsp;ts)&nbsp;+&nbsp;1.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence"><span class="id" type="section">Convergence</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Consider&nbsp;any&nbsp;valid&nbsp;task&nbsp;set.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>: <a class="idref" href="task.html#SporadicTaskset.taskset_of"><span class="id" type="definition">taskset_of</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.H_valid_task_parameters"><span class="id" type="variable">H_valid_task_parameters</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="task.html#SporadicTaskset.valid_sporadic_taskset"><span class="id" type="definition">valid_sporadic_taskset</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;To&nbsp;simplify,&nbsp;let&nbsp;f&nbsp;denote&nbsp;the&nbsp;RTA&nbsp;procedure.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> (<span class="id" type="var">k</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) := <span class="id" type="definition">iter</span> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Since&nbsp;the&nbsp;iteration&nbsp;is&nbsp;applied&nbsp;directly&nbsp;to&nbsp;a&nbsp;list&nbsp;of&nbsp;tasks&nbsp;and&nbsp;response-times,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we&nbsp;define&nbsp;a&nbsp;corresponding&nbsp;relation&nbsp;"&lt;="&nbsp;over&nbsp;those&nbsp;lists.&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Let&nbsp;'all_le'&nbsp;be&nbsp;a&nbsp;binary&nbsp;relation&nbsp;over&nbsp;lists&nbsp;of&nbsp;tasks/response-time&nbsp;bounds.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It&nbsp;states&nbsp;that&nbsp;every&nbsp;element&nbsp;of&nbsp;list&nbsp;l1&nbsp;has&nbsp;a&nbsp;response-time&nbsp;bound&nbsp;R&nbsp;that&nbsp;is&nbsp;less<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the&nbsp;corresponding&nbsp;response-time&nbsp;bound&nbsp;R'&nbsp;in&nbsp;list&nbsp;l2&nbsp;(point-wise).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In&nbsp;addition,&nbsp;the&nbsp;relation&nbsp;states&nbsp;that&nbsp;the&nbsp;tasks&nbsp;of&nbsp;both&nbsp;lists&nbsp;are&nbsp;unchanged.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a> := <span class="id" type="keyword">fun</span> (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">(</span></a><span class="id" type="definition">unzip1</span> <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a> <span class="id" type="notation">==</span> <span class="id" type="definition">unzip1</span> <a class="idref" href="bertogna_edf_comp.html#l2"><span class="id" type="variable">l2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">all</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> =&gt; <span class="id" type="notation">(</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" type="definition">snd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#fst"><span class="id" type="definition">fst</span></a> <a class="idref" href="bertogna_edf_comp.html#p"><span class="id" type="variable">p</span></a>)<span class="id" type="notation">)</span> <span class="id" type="notation">&lt;=</span> <span class="id" type="notation">(</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" type="definition">snd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" type="definition">snd</span></a> <a class="idref" href="bertogna_edf_comp.html#p"><span class="id" type="variable">p</span></a>)<span class="id" type="notation">)</span>) (<span class="id" type="definition">zip</span> <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="bertogna_edf_comp.html#l2"><span class="id" type="variable">l2</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Similarly,&nbsp;we&nbsp;define&nbsp;a&nbsp;strict&nbsp;version&nbsp;of&nbsp;'all_le'&nbsp;called&nbsp;'one_lt',&nbsp;which&nbsp;states&nbsp;that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there&nbsp;exists&nbsp;at&nbsp;least&nbsp;one&nbsp;element&nbsp;whose&nbsp;response-time&nbsp;bound&nbsp;increases.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.one_lt"><span class="id" type="variable">one_lt</span></a> := <span class="id" type="keyword">fun</span> (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_with_response_time"><span class="id" type="variable">task_with_response_time</span></a>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">(</span></a><span class="id" type="definition">unzip1</span> <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a> <span class="id" type="notation">==</span> <span class="id" type="definition">unzip1</span> <a class="idref" href="bertogna_edf_comp.html#l2"><span class="id" type="variable">l2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:bool_scope:x_'&&'_x"><span class="id" type="notation">&amp;&amp;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">has</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> =&gt; <span class="id" type="notation">(</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" type="definition">snd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#fst"><span class="id" type="definition">fst</span></a> <a class="idref" href="bertogna_edf_comp.html#p"><span class="id" type="variable">p</span></a>)<span class="id" type="notation">)</span> <span class="id" type="notation">&lt;</span> <span class="id" type="notation">(</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" type="definition">snd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" type="definition">snd</span></a> <a class="idref" href="bertogna_edf_comp.html#p"><span class="id" type="variable">p</span></a>)<span class="id" type="notation">)</span>) (<span class="id" type="definition">zip</span> <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="bertogna_edf_comp.html#l2"><span class="id" type="variable">l2</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Next,&nbsp;we&nbsp;prove&nbsp;some&nbsp;basic&nbsp;properties&nbsp;about&nbsp;the&nbsp;relation&nbsp;all_le.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.RelationProperties"><span class="id" type="section">RelationProperties</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;relation&nbsp;is&nbsp;reflexive,&nbsp;...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.all_le_reflexive"><span class="id" type="lemma">all_le_reflexive</span></a> : <span class="id" type="definition">reflexive</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...&nbsp;and&nbsp;transitive.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.all_le_transitive"><span class="id" type="lemma">all_le_transitive</span></a>: <span class="id" type="definition">transitive</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;any&nbsp;step&nbsp;of&nbsp;the&nbsp;iteration,&nbsp;the&nbsp;corresponding&nbsp;list<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;larger&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the&nbsp;initial&nbsp;state.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_iteration_preserves_minimum"><span class="id" type="lemma">bertogna_edf_comp_iteration_preserves_minimum</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">step</span>, <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>) (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#step"><span class="id" type="variable">step</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;As&nbsp;a&nbsp;last&nbsp;step,&nbsp;we&nbsp;show&nbsp;that&nbsp;edf_rta_iteration&nbsp;preserves&nbsp;order,&nbsp;i.e.,&nbsp;for&nbsp;any<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;l1&nbsp;no&nbsp;smaller&nbsp;than&nbsp;the&nbsp;initial&nbsp;state,&nbsp;and&nbsp;list&nbsp;l2&nbsp;such&nbsp;that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1&nbsp;&lt;=&nbsp;l2,&nbsp;we&nbsp;have&nbsp;(edf_rta_iteration&nbsp;l1)&nbsp;&lt;=&nbsp;(edf_rta_iteration&nbsp;l2).&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_iteration_preserves_order"><span class="id" type="lemma">bertogna_edf_comp_iteration_preserves_order</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.initial_state"><span class="id" type="variable">initial_state</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>) <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a> <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="bertogna_edf_comp.html#l2"><span class="id" type="variable">l2</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> <a class="idref" href="bertogna_edf_comp.html#l1"><span class="id" type="variable">l1</span></a>) (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_rta_iteration"><span class="id" type="definition">edf_rta_iteration</span></a> <a class="idref" href="bertogna_edf_comp.html#l2"><span class="id" type="variable">l2</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;It&nbsp;follows&nbsp;from&nbsp;the&nbsp;properties&nbsp;above&nbsp;that&nbsp;the&nbsp;iteration&nbsp;is&nbsp;monotonically&nbsp;increasing.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_iteration_monotonic"><span class="id" type="lemma">bertogna_edf_comp_iteration_monotonic</span></a>: <span class="id" type="keyword">forall</span> <span class="id" type="var">k</span>, <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.all_le"><span class="id" type="variable">all_le</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a>) (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a><span class="id" type="notation">.+1</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.RelationProperties"><span class="id" type="section">RelationProperties</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Knowing&nbsp;that&nbsp;the&nbsp;iteration&nbsp;is&nbsp;monotonically&nbsp;increasing&nbsp;(with&nbsp;respect&nbsp;to&nbsp;all_le),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we&nbsp;show&nbsp;that&nbsp;the&nbsp;RTA&nbsp;procedure&nbsp;converges&nbsp;to&nbsp;a&nbsp;fixed&nbsp;point.&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;First,&nbsp;note&nbsp;that&nbsp;when&nbsp;there&nbsp;are&nbsp;no&nbsp;tasks,&nbsp;the&nbsp;iteration&nbsp;trivially&nbsp;converges.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_f_converges_with_no_tasks"><span class="id" type="lemma">bertogna_edf_comp_f_converges_with_no_tasks</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition">size</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <span class="id" type="notation">(</span><a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a><span class="id" type="notation">).+1</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Otherwise,&nbsp;if&nbsp;the&nbsp;iteration&nbsp;reached&nbsp;a&nbsp;fixed&nbsp;point&nbsp;before&nbsp;(max_steps&nbsp;ts),&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;value&nbsp;at&nbsp;(max_steps&nbsp;ts)&nbsp;is&nbsp;still&nbsp;at&nbsp;a&nbsp;fixed&nbsp;point.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_f_converges_early"><span class="id" type="lemma">bertogna_edf_comp_f_converges_early</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">exists</span></a> <span class="id" type="var">k</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a><span class="id" type="notation">.+1</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <span class="id" type="notation">(</span><a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a><span class="id" type="notation">).+1</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Else,&nbsp;we&nbsp;derive&nbsp;a&nbsp;contradiction.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.DerivingContradiction"><span class="id" type="section">DerivingContradiction</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Assume&nbsp;that&nbsp;there&nbsp;are&nbsp;tasks.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.DerivingContradiction.H_at_least_one_task"><span class="id" type="variable">H_at_least_one_task</span></a>: <span class="id" type="definition">size</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> <span class="id" type="notation">&gt;</span> 0.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Assume&nbsp;that&nbsp;the&nbsp;iteration&nbsp;continued&nbsp;to&nbsp;diverge.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.Convergence.DerivingContradiction.H_keeps_diverging"><span class="id" type="variable">H_keeps_diverging</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> -&gt; <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <span class="id" type="notation">!=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a><span class="id" type="notation">.+1</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Since&nbsp;the&nbsp;iteration&nbsp;is&nbsp;monotonically&nbsp;increasing,&nbsp;it&nbsp;must&nbsp;be<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strictly&nbsp;increasing.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_f_increases"><span class="id" type="lemma">bertogna_edf_comp_f_increases</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> -&gt; <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.one_lt"><span class="id" type="variable">one_lt</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a>) (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a><span class="id" type="notation">.+1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;the&nbsp;end,&nbsp;each&nbsp;response-time&nbsp;bound&nbsp;is&nbsp;so&nbsp;high&nbsp;that&nbsp;the&nbsp;sum<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;all&nbsp;response-time&nbsp;bounds&nbsp;exceeds&nbsp;the&nbsp;sum&nbsp;of&nbsp;all&nbsp;deadlines.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contradiction!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.bertogna_edf_comp_rt_grows_too_much"><span class="id" type="lemma">bertogna_edf_comp_rt_grows_too_much</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">\</span></a><a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">sum_</span></a><a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">((</span></a><span class="id" type="var">tsk</span><a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">R</span><a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">&lt;-</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a><a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">R</span> <span class="id" type="notation">-</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <span class="id" type="var">tsk</span><a class="idref" href="util_lemmas.html#:nat_scope:'\sum_'_'('_'('_x_','_x_')'_'<-'_x_')'_x"><span class="id" type="notation">)</span></a> <span class="id" type="notation">+</span> 1 <span class="id" type="notation">&gt;</span> <a class="idref" href="bertogna_edf_comp.html#k"><span class="id" type="variable">k</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.DerivingContradiction"><span class="id" type="section">DerivingContradiction</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Using&nbsp;the&nbsp;lemmas&nbsp;above,&nbsp;we&nbsp;prove&nbsp;that&nbsp;edf_rta_iteration&nbsp;reaches&nbsp;a&nbsp;fixed&nbsp;point<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after&nbsp;(max_steps&nbsp;ts)&nbsp;iterations,&nbsp;...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_converges_helper"><span class="id" type="lemma">edf_claimed_bounds_converges_helper</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">rt_bounds</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="task.html#SporadicTaskset.valid_sporadic_taskset"><span class="id" type="definition">valid_sporadic_taskset</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.f"><span class="id" type="variable">f</span></a> <span class="id" type="notation">(</span><a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.max_steps"><span class="id" type="variable">max_steps</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a><span class="id" type="notation">).+1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Either&nbsp;the&nbsp;task&nbsp;set&nbsp;is&nbsp;empty&nbsp;or&nbsp;not.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Either&nbsp;f&nbsp;converges&nbsp;by&nbsp;the&nbsp;deadline&nbsp;or&nbsp;not.&nbsp;*)</span><br/>
&nbsp;If&nbsp;not,&nbsp;then&nbsp;we&nbsp;reach&nbsp;a&nbsp;contradiction&nbsp;*)</span><br/>
&nbsp;Show&nbsp;that&nbsp;the&nbsp;sum&nbsp;is&nbsp;less&nbsp;than&nbsp;the&nbsp;sum&nbsp;of&nbsp;all&nbsp;deadlines.&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...,&nbsp;which&nbsp;in&nbsp;turn&nbsp;implies&nbsp;that&nbsp;the&nbsp;response-time&nbsp;bound&nbsp;is&nbsp;the&nbsp;fixed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;from&nbsp;Bertogna&nbsp;and&nbsp;Cirinei's&nbsp;equation.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="ResponseTimeIterationEDF.edf_claimed_bounds_converges"><span class="id" type="lemma">edf_claimed_bounds_converges</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tsk</span> <span class="id" type="var">R</span> <span class="id" type="var">rt_bounds</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence.ts"><span class="id" type="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" type="constructor">Some</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="notation">+</span> <a class="idref" href="util_divround.html#div_floor"><span class="id" type="definition">div_floor</span></a> (<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.I"><span class="id" type="variable">I</span></a> <a class="idref" href="bertogna_edf_comp.html#rt_bounds"><span class="id" type="variable">rt_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a>) <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.num_cpus"><span class="id" type="variable">num_cpus</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Convergence"><span class="id" type="section">Convergence</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof"><span class="id" type="section">MainProof</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Consider&nbsp;a&nbsp;task&nbsp;set&nbsp;ts.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a>: <a class="idref" href="task.html#SporadicTaskset.taskset_of"><span class="id" type="definition">taskset_of</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Assume&nbsp;the&nbsp;task&nbsp;set&nbsp;has&nbsp;no&nbsp;duplicates,&nbsp;...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_ts_is_a_set"><span class="id" type="variable">H_ts_is_a_set</span></a>: <span class="id" type="definition">uniq</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...all&nbsp;tasks&nbsp;have&nbsp;valid&nbsp;parameters,&nbsp;...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_valid_task_parameters"><span class="id" type="variable">H_valid_task_parameters</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="task.html#SporadicTaskset.valid_sporadic_taskset"><span class="id" type="definition">valid_sporadic_taskset</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...restricted&nbsp;deadlines,&nbsp;...*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_restricted_deadlines"><span class="id" type="variable">H_restricted_deadlines</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tsk</span>, <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a> -&gt; <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="notation">&lt;=</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Next,&nbsp;consider&nbsp;any&nbsp;arrival&nbsp;sequence&nbsp;such&nbsp;that...*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Context</span> {<span class="id" type="var">arr_seq</span>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.arrival_sequence"><span class="id" type="definition">arrival_sequence</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Job"><span class="id" type="variable">Job</span></a>}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...all&nbsp;jobs&nbsp;come&nbsp;from&nbsp;task&nbsp;set&nbsp;ts,&nbsp;...*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_all_jobs_from_taskset"><span class="id" type="variable">H_all_jobs_from_taskset</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">j</span>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.JobIn"><span class="id" type="record">JobIn</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a>), <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a> <a class="idref" href="bertogna_edf_comp.html#j"><span class="id" type="variable">j</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...they&nbsp;have&nbsp;valid&nbsp;parameters,...*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_valid_job_parameters"><span class="id" type="variable">H_valid_job_parameters</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">j</span>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.JobIn"><span class="id" type="record">JobIn</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="job.html#Job.valid_sporadic_job"><span class="id" type="definition">valid_sporadic_job</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_cost"><span class="id" type="variable">task_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_deadline"><span class="id" type="variable">task_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_deadline"><span class="id" type="variable">job_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a> <a class="idref" href="bertogna_edf_comp.html#j"><span class="id" type="variable">j</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...&nbsp;and&nbsp;satisfy&nbsp;the&nbsp;sporadic&nbsp;task&nbsp;model.*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_sporadic_tasks"><span class="id" type="variable">H_sporadic_tasks</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="task_arrival.html#SporadicTaskArrival.sporadic_task_model"><span class="id" type="definition">sporadic_task_model</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.task_period"><span class="id" type="variable">task_period</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Then,&nbsp;consider&nbsp;any&nbsp;platform&nbsp;with&nbsp;at&nbsp;least&nbsp;one&nbsp;CPU&nbsp;such&nbsp;that...*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a>: <a class="idref" href="schedule.html#Schedule.schedule"><span class="id" type="definition">schedule</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.num_cpus"><span class="id" type="variable">num_cpus</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_at_least_one_cpu"><span class="id" type="variable">H_at_least_one_cpu</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.num_cpus"><span class="id" type="variable">num_cpus</span></a> <span class="id" type="notation">&gt;</span> 0.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...jobs&nbsp;only&nbsp;execute&nbsp;after&nbsp;they&nbsp;arrived&nbsp;and&nbsp;no&nbsp;longer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;than&nbsp;their&nbsp;execution&nbsp;costs,...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_jobs_must_arrive_to_execute"><span class="id" type="variable">H_jobs_must_arrive_to_execute</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedule.html#Schedule.jobs_must_arrive_to_execute"><span class="id" type="definition">jobs_must_arrive_to_execute</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_completed_jobs_dont_execute"><span class="id" type="variable">H_completed_jobs_dont_execute</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedule.html#Schedule.completed_jobs_dont_execute"><span class="id" type="definition">completed_jobs_dont_execute</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...and&nbsp;do&nbsp;not&nbsp;execute&nbsp;in&nbsp;parallel.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_no_parallelism"><span class="id" type="variable">H_no_parallelism</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedule.html#Schedule.jobs_dont_execute_in_parallel"><span class="id" type="definition">jobs_dont_execute_in_parallel</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;order&nbsp;not&nbsp;to&nbsp;overcount&nbsp;job&nbsp;interference,&nbsp;we&nbsp;assume&nbsp;that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobs&nbsp;of&nbsp;the&nbsp;same&nbsp;task&nbsp;do&nbsp;not&nbsp;execute&nbsp;in&nbsp;parallel.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our&nbsp;proof&nbsp;requires&nbsp;a&nbsp;definition&nbsp;of&nbsp;interference&nbsp;based&nbsp;on<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;sum&nbsp;of&nbsp;the&nbsp;individual&nbsp;contributions&nbsp;of&nbsp;each&nbsp;job:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I_total&nbsp;=&nbsp;I_j1&nbsp;+&nbsp;I_j2&nbsp;+&nbsp;...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note&nbsp;that&nbsp;under&nbsp;EDF,&nbsp;this&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;task&nbsp;precedence<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraints.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_no_intra_task_parallelism"><span class="id" type="variable">H_no_intra_task_parallelism</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedule.html#ScheduleOfSporadicTask.jobs_of_same_task_dont_execute_in_parallel"><span class="id" type="definition">jobs_of_same_task_dont_execute_in_parallel</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Assume&nbsp;that&nbsp;the&nbsp;schedule&nbsp;satisfies&nbsp;the&nbsp;global&nbsp;scheduling<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invariant&nbsp;with&nbsp;EDF&nbsp;priority,&nbsp;i.e.,&nbsp;if&nbsp;any&nbsp;job&nbsp;of&nbsp;tsk&nbsp;is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backlogged,&nbsp;every&nbsp;processor&nbsp;must&nbsp;be&nbsp;busy&nbsp;with&nbsp;jobs&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;no&nbsp;greater&nbsp;absolute&nbsp;deadline.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.higher_eq_priority"><span class="id" type="variable">higher_eq_priority</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="priority.html#Priority.EDF"><span class="id" type="definition">EDF</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.Job"><span class="id" type="variable">Job</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_deadline"><span class="id" type="variable">job_deadline</span></a>. <span class="comment">(*&nbsp;TODO:&nbsp;implicit&nbsp;params&nbsp;seems&nbsp;broken&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_global_scheduling_invariant"><span class="id" type="variable">H_global_scheduling_invariant</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="platform.html#Platform.JLFP_JLDP_scheduling_invariant_holds"><span class="id" type="definition">JLFP_JLDP_scheduling_invariant_holds</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.num_cpus"><span class="id" type="variable">num_cpus</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.higher_eq_priority"><span class="id" type="variable">higher_eq_priority</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.no_deadline_missed_by_task"><span class="id" type="definition">no_deadline_missed_by_task</span></a> (<span class="id" type="var">tsk</span>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.sporadic_task"><span class="id" type="variable">sporadic_task</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedulability.html#Schedulability.task_misses_no_deadline"><span class="id" type="definition">task_misses_no_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_deadline"><span class="id" type="variable">job_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="ResponseTimeIterationEDF.no_deadline_missed_by_job"><span class="id" type="definition">no_deadline_missed_by_job</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedulability.html#Schedulability.job_misses_no_deadline"><span class="id" type="definition">job_misses_no_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_deadline"><span class="id" type="variable">job_deadline</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;the&nbsp;following&nbsp;theorem,&nbsp;we&nbsp;prove&nbsp;that&nbsp;any&nbsp;response-time&nbsp;bound&nbsp;contained<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;edf_claimed_bounds&nbsp;is&nbsp;safe.&nbsp;The&nbsp;proof&nbsp;follows&nbsp;by&nbsp;direct&nbsp;application&nbsp;of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;main&nbsp;Theorem&nbsp;from&nbsp;bertogna_edf_theory.v.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="ResponseTimeIterationEDF.edf_analysis_yields_response_time_bounds"><span class="id" type="lemma">edf_analysis_yields_response_time_bounds</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tsk</span> <span class="id" type="var">R</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <a class="idref" href="util_lemmas.html#:bool_scope:x_'\In'_x"><span class="id" type="notation">\</span></a><a class="idref" href="util_lemmas.html#:bool_scope:x_'\In'_x"><span class="id" type="notation">In</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_claimed_bounds"><span class="id" type="definition">edf_claimed_bounds</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">j</span> : <a class="idref" href="arrival_sequence.html#ArrivalSequence.JobIn"><span class="id" type="record">JobIn</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_task"><span class="id" type="variable">job_task</span></a> <a class="idref" href="bertogna_edf_comp.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl4/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="schedule.html#Schedule.completed"><span class="id" type="definition">completed</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.job_cost"><span class="id" type="variable">job_cost</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.sched"><span class="id" type="variable">sched</span></a> <a class="idref" href="bertogna_edf_comp.html#j"><span class="id" type="variable">j</span></a> (<a class="idref" href="arrival_sequence.html#ArrivalSequence.job_arrival"><span class="id" type="definition">job_arrival</span></a> <a class="idref" href="bertogna_edf_comp.html#j"><span class="id" type="variable">j</span></a> <span class="id" type="notation">+</span> <a class="idref" href="bertogna_edf_comp.html#R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Therefore,&nbsp;if&nbsp;the&nbsp;schedulability&nbsp;test&nbsp;suceeds,&nbsp;...*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Hypothesis</span> <a name="ResponseTimeIterationEDF.Analysis.MainProof.H_test_succeeds"><span class="id" type="variable">H_test_succeeds</span></a>: <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.edf_schedulable"><span class="id" type="definition">edf_schedulable</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*...&nbsp;no&nbsp;task&nbsp;misses&nbsp;its&nbsp;deadline.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="ResponseTimeIterationEDF.taskset_schedulable_by_edf_rta"><span class="id" type="lemma">taskset_schedulable_by_edf_rta</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tsk</span>, <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a> <span class="id" type="notation">\</span><span class="id" type="keyword">in</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.ts"><span class="id" type="variable">ts</span></a> -&gt; <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.no_deadline_missed_by_task"><span class="id" type="definition">no_deadline_missed_by_task</span></a> <a class="idref" href="bertogna_edf_comp.html#tsk"><span class="id" type="variable">tsk</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;For&nbsp;completeness,&nbsp;since&nbsp;all&nbsp;jobs&nbsp;of&nbsp;the&nbsp;arrival&nbsp;sequence<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;spawned&nbsp;by&nbsp;the&nbsp;task&nbsp;set,&nbsp;we&nbsp;conclude&nbsp;that&nbsp;no&nbsp;job&nbsp;misses<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;its&nbsp;deadline.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="ResponseTimeIterationEDF.jobs_schedulable_by_edf_rta"><span class="id" type="lemma">jobs_schedulable_by_edf_rta</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">j</span>: <a class="idref" href="arrival_sequence.html#ArrivalSequence.JobIn"><span class="id" type="record">JobIn</span></a> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof.arr_seq"><span class="id" type="variable">arr_seq</span></a>), <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.no_deadline_missed_by_job"><span class="id" type="definition">no_deadline_missed_by_job</span></a> <a class="idref" href="bertogna_edf_comp.html#j"><span class="id" type="variable">j</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis.MainProof"><span class="id" type="section">MainProof</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#ResponseTimeIterationEDF.Analysis"><span class="id" type="section">Analysis</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="bertogna_edf_comp.html#"><span class="id" type="module">ResponseTimeIterationEDF</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>