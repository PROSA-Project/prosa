Require Export prosa.analysis.facts.model.workload.
Require Export prosa.analysis.facts.model.ideal.service_of_jobs.
Require Export prosa.analysis.facts.busy_interval.quiet_time.
Require Export prosa.analysis.definitions.work_bearing_readiness.
Require Export prosa.model.schedule.work_conserving.
Require Export prosa.util.tactics.

(** * Existence of No Carry-In Instant *)

(** In this section, we derive an alternative condition for the
    existence of a busy interval. The new condition requires the total
    workload (instead of the high-priority workload) generated by the
    task set to be bounded. *)

(** Next, we derive a sufficient condition for existence of
    no carry-in instant for uniprocessor for JLFP schedulers *)
Section ExistsNoCarryIn.

  (** Consider any type of tasks ... *)
  Context {Task : TaskType}.
  Context `{TaskCost Task}.

  (**  ... and any type of jobs associated with these tasks. *)
  Context {Job : JobType}.
  Context `{JobTask Job Task}.
  Context {Arrival: JobArrival Job}.
  Context {Cost : JobCost Job}.

  (** Consider any valid arrival sequence. *)
  Variable arr_seq : arrival_sequence Job.
  Hypothesis H_valid_arr_seq : valid_arrival_sequence arr_seq.

  (** Allow for any uniprocessor model that ensures ideal progress. *)
  Context {PState : ProcessorState Job}.
  Hypothesis H_ideal_progress_proc_model : ideal_progress_proc_model PState.
  Hypothesis H_uniproc : uniprocessor_model PState.

  (** Next, consider any schedule of the arrival sequence ... *)
  Variable sched : schedule PState.
  Hypothesis H_jobs_come_from_arrival_sequence:
    jobs_come_from_arrival_sequence sched arr_seq.

  (** ... where jobs do not execute before their arrival or after completion. *)
  Hypothesis H_jobs_must_arrive_to_execute : jobs_must_arrive_to_execute sched.
  Hypothesis H_completed_jobs_dont_execute : completed_jobs_dont_execute sched.

  (** Assume a given JLFP policy. *)
  Context {JLFP : JLFP_policy Job}.

  (** For simplicity, let's define some local names. *)
  Let job_pending_at := pending sched.
  Let job_completed_by := completed_by sched.
  Let arrivals_between := arrivals_between arr_seq.
  Let no_carry_in := no_carry_in arr_seq sched.
  Let quiet_time := quiet_time arr_seq sched.

  (** Further, allow for any work-bearing notion of job readiness ... *)
  Context `{@JobReady Job PState Cost Arrival}.
  Hypothesis H_job_ready : work_bearing_readiness arr_seq sched.

  (** ... and assume that the schedule is work-conserving. *)
  Hypothesis H_work_conserving : work_conserving arr_seq sched.

  (** Conversely, the presence of a pending job implies that the processor isn't
      idle due to work-conservation. *)
  Lemma pending_job_implies_not_idle :
    forall j t,
      arrives_in arr_seq j ->
      pending sched j t ->
      ~ is_idle arr_seq sched t.
  Proof.
    move=> j t ARR PEND IDLE.
    apply H_job_ready in PEND => //; move: PEND => [jhp [ARRhp [READYhp _]]].
    move: IDLE; rewrite is_idle_iff => /eqP; rewrite scheduled_job_at_none => // IDLE.
    have [j_other SCHED]:  exists j_other : Job, scheduled_at sched j_other t.
      by apply: H_work_conserving ARRhp _; apply/andP.
    by move: (IDLE j_other) => /negP.
  Qed.

  (** We show that an idle time implies no carry in at this time instant. *)
  Lemma idle_instant_implies_no_carry_in_at_t :
    forall t,
      is_idle arr_seq sched t ->
      no_carry_in t.
  Proof.
    move=> t IDLE j ARR HA.
    apply/negPn/negP =>  NCOMP.
    have PEND : job_pending_at j t by apply/andP; split; rewrite // /has_arrived ltnW.
    by apply: (pending_job_implies_not_idle j t).
  Qed.

  (** Moreover, an idle time implies no carry in at the next time instant. *)
  Lemma idle_instant_implies_no_carry_in_at_t_pl_1 :
    forall t,
      is_idle arr_seq sched t ->
      no_carry_in t.+1.
  Proof.
    move=> t IDLE j ARR HA.
    apply/negPn/negP; intros NCOMP.
    have PEND : job_pending_at j t.
    { apply/andP; split; rewrite // /has_arrived.
      apply/contra; last exact NCOMP.
      by apply/completion_monotonic. }
    by apply: (pending_job_implies_not_idle j t).
  Qed.

  (** Let the priority relation be reflexive. *)
  Hypothesis H_priority_is_reflexive: reflexive_job_priorities JLFP.

  (** Recall the notion of workload of all jobs released in a given interval
      <<[t1, t2)>>... *)
  Let total_workload t1 t2 :=
    workload_of_jobs predT (arrivals_between t1 t2).

  (** ... and total service of jobs within some time interval <<[t1, t2)>>. *)
  Let total_service t1 t2 :=
    service_of_jobs sched predT (arrivals_between 0 t2) t1 t2.

  (** Assume that for some positive [Δ], the sum of requested workload
      at time [t + Δ] is bounded by [Δ] (i.e., the supply). Note that
      this assumption bounds the total workload of jobs released in a
      time interval <<[t, t + Δ)>> regardless of their priorities. *)
  Variable Δ : duration.
  Hypothesis H_delta_positive : Δ > 0.
  Hypothesis H_workload_is_bounded : forall t, total_workload t (t + Δ) <= Δ.

  (** In the following, we also require the processor to be a unit-speed
      processor. *)
  Hypothesis H_unit_service_proc_model : unit_service_proc_model PState.

  (** Next we prove that, since for any time instant [t] there is a
      point where the total workload is upper-bounded by the supply,
      the processor encounters no-carry-in instants at least every [Δ]
      time units. *)
  Section ProcessorIsNotTooBusy.

    (** We start by proving that the processor has no carry-in at the
        beginning (i.e., has no carry-in at time instant [0]). *)
    Lemma no_carry_in_at_the_beginning :
      no_carry_in 0.
    Proof.
      intros s ARR AB; exfalso.
      by rewrite /arrived_before ltn0 in AB.
    Qed.

    (** In this section, we prove that for any time instant [t] there
        exists another time instant <<t' ∈ (t, t + Δ]>> such that the
        processor has no carry-in at time [t']. *)
    Section ProcessorIsNotTooBusyInduction.

      (** Consider an arbitrary time instant [t]... *)
      Variable t : duration.

      (** ...such that the processor has no carry-in at time [t]. *)
      Hypothesis H_no_carry_in : no_carry_in t.

      (** First, recall that the total service is bounded by the total
          workload. Therefore the total service of jobs in the interval <<[t, t
          + Δ)>> is bounded by [Δ]. *)
      Lemma total_service_is_bounded_by_Δ :
        total_service t (t + Δ) <= Δ.
      Proof.
        unfold total_service.
        rewrite -{3}[Δ]addn0 -{2}(subnn t) addnBA // [in X in _ <= X]addnC.
        apply service_of_jobs_le_length_of_interval' => //.
        exact: arrivals_uniq.
      Qed.

      (** Next we consider two cases:
          (1) The case when the total service is strictly less than [Δ], and
          (2) the case when the total service is equal to [Δ]. *)

      (** In the first case, we use the pigeonhole principle to
          conclude that there is an idle time instant; which in turn
          implies existence of a time instant with no carry-in. *)
      Lemma low_total_service_implies_existence_of_time_with_no_carry_in :
        total_service t (t + Δ) < Δ ->
        exists δ, δ < Δ /\ no_carry_in (t.+1 + δ).
      Proof.
        unfold total_service; intros LT.
        rewrite -{3}[Δ]addn0 -{2}(subnn t) addnBA // [Δ + t]addnC in LT.
        eapply low_service_implies_existence_of_idle_time in LT => //.
        move: LT => [t_idle [/andP [LEt GTe] IDLE]].
        move: LEt; rewrite leq_eqVlt; move => /orP [/eqP EQ|LT].
        { exists 0; split => //.
          rewrite addn0; subst t_idle => s ARR BEF.
          by apply idle_instant_implies_no_carry_in_at_t_pl_1 in IDLE. }
        have EX: exists γ, t_idle = t + γ.
        { by exists (t_idle - t); rewrite subnKC // ltnW. }
        move: EX => [γ EQ]; subst t_idle; rewrite ltn_add2l in GTe.
        rewrite -{1}[t]addn0 ltn_add2l in LT.
        exists (γ.-1); split.
        - apply leq_trans with γ. by rewrite prednK. by rewrite ltnW.
        - rewrite -subn1 -addn1 -addnA subnKC //.
          intros s ARR BEF.
          exact: idle_instant_implies_no_carry_in_at_t.
      Qed.

      (** In the second case, the total service within the time
          interval <<[t, t + Δ)>> is equal to [Δ]. On the other hand,
          we know that the total workload is lower-bounded by the
          total service and upper-bounded by [Δ]. Therefore, the total
          workload is equal to the total service, which implies
          completion of all jobs by time [t + Δ] and hence no carry-in
          at time [t + Δ]. *)
      Lemma completion_of_all_jobs_implies_no_carry_in :
        total_service t (t + Δ) = Δ ->
        no_carry_in (t + Δ).
      Proof.
        unfold total_service; intros EQserv.
        move: (H_workload_is_bounded t); move => WORK.
        have EQ: total_workload 0 (t + Δ) = service_of_jobs sched predT (arrivals_between 0 (t + Δ)) 0 (t + Δ).
        { have CONSIST: consistent_arrival_times arr_seq by [].
          have COMPL := all_jobs_have_completed_impl_workload_eq_service
                          _ arr_seq CONSIST sched
                          H_jobs_must_arrive_to_execute
                          H_completed_jobs_dont_execute
                          predT 0 t t.
          feed_n 2 COMPL => //.
          { intros j A B; apply H_no_carry_in.
            - eapply in_arrivals_implies_arrived; eauto 2.
            - eapply in_arrivals_implies_arrived_between in A; eauto 2.
          }
          apply/eqP; rewrite eqn_leq; apply/andP; split;
            last by apply service_of_jobs_le_workload.
          rewrite /total_workload (workload_of_jobs_cat arr_seq t); last first.
            by apply/andP; split; [|rewrite leq_addr].
          rewrite (service_of_jobs_cat_scheduling_interval _ _ _ _ _ _ _ t)//; first last.
          { by apply/andP; split; [|rewrite leq_addr]. }
          rewrite COMPL -addnA leq_add2l.
          rewrite -service_of_jobs_cat_arrival_interval; last first.
            by apply/andP; split; [|rewrite leq_addr].
          rewrite EQserv.
          by apply H_workload_is_bounded.
        }
        intros s ARR BEF.
        exact: workload_eq_service_impl_all_jobs_have_completed.
      Qed.

    End ProcessorIsNotTooBusyInduction.

    (** Finally, we show that any interval of length [Δ] contains a time instant
        with no carry-in. *)
    Lemma processor_is_not_too_busy :
      forall t, exists δ, δ < Δ /\ no_carry_in (t + δ).
    Proof.
      elim=> [|t IHt].
      { by exists 0; split; [ | rewrite addn0; apply no_carry_in_at_the_beginning]. }
      { move: IHt => [δ [LE FQT]].
        move: (posnP δ) => [Z|POS]; last first.
        { exists (δ.-1); split.
          - by apply leq_trans with δ; [rewrite prednK | apply ltnW].
          - by rewrite -subn1 -addn1 -addnA subnKC //.
        } subst δ; rewrite addn0 in FQT; clear LE.
        move: (total_service_is_bounded_by_Δ t); rewrite leq_eqVlt; move => /orP [/eqP EQ | LT].
        - exists (Δ.-1); split.
          + by rewrite prednK.
          + by rewrite addSn -subn1 -addn1 -addnA subnK; first apply completion_of_all_jobs_implies_no_carry_in.
        - by apply low_total_service_implies_existence_of_time_with_no_carry_in.
      }
    Qed.

  End ProcessorIsNotTooBusy.


End ExistsNoCarryIn.
